<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Storage</name>
    </assembly>
    <members>
        <member name="T:Storage.Algorithms.BinarySearch">
            <summary>
            Static class for binary-search methods.
            </summary>
        </member>
        <member name="M:Storage.Algorithms.BinarySearch.CalculateSearchComplexity(System.Int64)">
            <summary>
            Calculates the maximum number of iterations for a binary search of <paramref name="n"/> elements.
            </summary>
            <param name="n">The number of elements.</param>
            <returns>The maximum number of iterations in a binary search of <paramref name="n"/> elements.</returns>
        </member>
        <member name="M:Storage.Algorithms.BinarySearch.TryFindIndex``2(Storage.IBinarySearchable{``0,``1},``0,System.Int64@,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)">
            <summary>
            Attempts to find the index of a particular key.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="searchable">The <see cref="T:Storage.IBinarySearchable`2"/> to search.</param>
            <param name="key">The key to find.</param>
            <param name="index">Upon success, assigned to the index where the <paramref name="key"/> was found.
            Upon failure, assigned to -1.</param>
            <param name="progressReporter"><see cref="T:System.IProgress`1"/> that receives a <see cref="T:Storage.ProgressReport"/> 
            as the search progresses. May be null, in which case progress will not be reported.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> that can be used to cancel the search
            operation. Upon cancellation, false is returned.</param>
            <returns>True if the <paramref name="key"/> was found, otherwise false. False indicates that the
            <paramref name="key"/> was not present in this <see cref="T:Storage.IBinarySearchable`2"/>, or that
            the search was cancelled via the <paramref name="cancellationToken"/>.</returns>
            <seealso cref="M:Storage.Algorithms.BinarySearch.TryFindValue``2(Storage.IBinarySearchable{``0,``1},``0,``1@,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
            <seealso cref="M:Storage.IBinarySearchable`2.GetValueAt(System.Int64)"/>
            <seealso cref="M:Storage.Algorithms.BinarySearch.TryFindCeiling``2(Storage.IBinarySearchable{``0,``1},``0,System.Int64@,``0@,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
            <seealso cref="M:Storage.Algorithms.BinarySearch.TryFindFloor``2(Storage.IBinarySearchable{``0,``1},``0,System.Int64@,``0@,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Storage.Algorithms.BinarySearch.TryFindValue``2(Storage.IBinarySearchable{``0,``1},``0,``1@,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)">
            <summary>
            Attempts to find the value that is associated to a particular key.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="searchable">The <see cref="T:Storage.IBinarySearchable`2"/> to search.</param>
            <param name="key">The key to find.</param>
            <param name="valueOrDefault">Upon success, assigned to the value that is associated to the
            <paramref name="key"/>. Upon failure, assigned to the default <typeparamref name="TValue"/>
            value.</param>
            <param name="progressReporter"><see cref="T:System.IProgress`1"/> that receives a <see cref="T:Storage.ProgressReport"/>
            as the search progresses. May be null, in which case progress will not be reported.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> that can be used to cancel the search
            operation. Upon cancellation, false is returned.</param>
            <returns>True if the <paramref name="key"/> was found, otherwise false. False indicates that the
            <paramref name="key"/> was not present in this <see cref="T:Storage.IBinarySearchable`2"/>, or that
            the search was cancelled via the <paramref name="cancellationToken"/>.</returns>
            <seealso cref="M:Storage.Algorithms.BinarySearch.TryFindIndex``2(Storage.IBinarySearchable{``0,``1},``0,System.Int64@,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
            <seealso cref="M:Storage.IBinarySearchable`2.GetValueAt(System.Int64)"/>
            <seealso cref="M:Storage.Algorithms.BinarySearch.TryFindCeiling``2(Storage.IBinarySearchable{``0,``1},``0,System.Int64@,``0@,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
            <seealso cref="M:Storage.Algorithms.BinarySearch.TryFindFloor``2(Storage.IBinarySearchable{``0,``1},``0,System.Int64@,``0@,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Storage.Algorithms.BinarySearch.TryFindCeiling``2(Storage.IBinarySearchable{``0,``1},``0,System.Int64@,``0@,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)">
            <summary>
            Attempts to find the lowest key that is greater than or equal to an input key.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="searchable">The <see cref="T:Storage.IBinarySearchable`2"/> to search.</param>
            <param name="key">The input key.</param>
            <param name="index">Upon success, assigned to the index of the lowest key that is greater than
            or equal to the input <paramref name="key"/>. Upon failure, assigned to -1.</param>
            <param name="keyOrDefault">Upon success, assigned to the key with the lowest value that is
            greater than or equal to the input <paramref name="key"/>. This will be the <typeparamref name="TKey"/>
            that is stored at <paramref name="index"/>. Upon failure, assigned to the default <typeparamref name="TKey"/>
            value.</param>
            <param name="progressReporter"><see cref="T:System.IProgress`1"/> that receives a <see cref="T:Storage.ProgressReport"/>
            as the search progresses. May be null, in which case progress will not be reported.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> that can be used to cancel the search
            operation. Upon cancellation, false is returned.</param>
            <returns>True if the ceiling was found, otherwise false. False indicates that there is no stored
            key that is greater than or equal to the input <paramref name="key"/>, or that the search was
            cancelled via the <paramref name="cancellationToken"/>.</returns>
        </member>
        <member name="M:Storage.Algorithms.BinarySearch.TryFindFloor``2(Storage.IBinarySearchable{``0,``1},``0,System.Int64@,``0@,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)">
            <summary>
            Attempts to find the highest key that is less than or equal to an input key.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="searchable">The <see cref="T:Storage.IBinarySearchable`2"/> to search.</param>
            <param name="key">The input key.</param>
            <param name="index">Upon success, assigned to the index of the highest key that is less than or
            equal to the input <paramref name="key"/>. Upon failure, assigned to -1.</param>
            <param name="keyOrDefault">Upon success, assigned to the key with the highest value that is less
            than or equal to the input <paramref name="key"/>. Upon failure, assigned to the default <typeparamref name="TKey"/>
            value.</param>
            <param name="progressReporter"><see cref="T:System.IProgress`1"/> that receives a <see cref="T:Storage.ProgressReport"/>
            as the search progresses. May be null, in which case progress will not be reported.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> that can be used to cancel the search
            operation. Upon cancellation, false is returned.</param>
            <returns>True if the floor was found, otherwise false. False indicates that there is no stored key
            that is less than or equal to the input <paramref name="key"/>, or that the search was cancelled via
            the <paramref name="cancellationToken"/>.</returns>
        </member>
        <member name="P:Storage.CachedPage.PageIndex">
            <summary>
            The index of the page on the base <see cref="T:Storage.IPageStorage"/>.
            </summary>
        </member>
        <member name="P:Storage.CachedPage.BasePageStorage">
            <summary>
            The base <see cref="T:Storage.IPageStorage"/>.
            </summary>
        </member>
        <member name="P:Storage.CachedPage.CachedPageStorage">
            <summary>
            The <see cref="T:Storage.CachedPageStorage"/> to which this <see cref="T:Storage.CachedPage"/>
            belongs.
            </summary>
        </member>
        <member name="P:Storage.CachedPage.WriteMode">
            <summary>
            The <see cref="T:Storage.CachedPageStorage.CacheWriteMode"/>.
            </summary>
        </member>
        <member name="P:Storage.CachedPage.RecentUseCounter">
            <summary>
            Value that is used to determine the 'most recently used' <see cref="T:Storage.CachedPage"/>s.
            Greater values are more recent.
            </summary>
        </member>
        <member name="M:Storage.CachedPage.Read(System.Int64,System.Byte[],System.Int64,System.Int64)">
            <summary>
            Reads from the page, updating cache where necessary.
            </summary>
            <param name="srcOffset">The source offset within the page's payload.</param>
            <param name="buffer">The destination buffer.</param>
            <param name="dstOffset">The offset within the destination <paramref name="buffer"/>.</param>
            <param name="length">The number of bytes to read.</param>
        </member>
        <member name="T:Storage.CachedPageStorage">
            <summary>
            <see cref="T:Storage.IPageStorage"/> that provides caching for another <see cref="T:Storage.IPageStorage"/> implementation.
            </summary>
            <remarks>
            When an <see cref="T:Storage.IPageStorage"/> implementation does not provide sufficient caching, the application should
            use this class to wrap the non-cached <see cref="T:Storage.IPageStorage"/>. This is particularly important for applications
            which may frequently repeat reads or writes to or from a page.
            </remarks>
        </member>
        <member name="P:Storage.CachedPageStorage.PageStorage">
            <summary>
            The base <see cref="T:Storage.IPageStorage"/>.
            </summary>
        </member>
        <member name="P:Storage.CachedPageStorage.WillLeaveBasePageStorageOpen">
            <summary>
            Will this <see cref="T:Storage.CachedPageStorage"/> leave the base <see cref="P:Storage.CachedPageStorage.PageStorage"/>
            open (un-disposed) after <see cref="M:Storage.CachedPageStorage.Dispose"/> is called?
            </summary>
        </member>
        <member name="P:Storage.CachedPageStorage.CachedPageCapacity">
            <summary>
            The maximum number of pages that will be stored in cache memory.
            </summary>
        </member>
        <member name="T:Storage.CachedPageStorage.CacheWriteMode">
            <summary>
            Defines the write mode of cache storage.
            </summary>
        </member>
        <member name="F:Storage.CachedPageStorage.CacheWriteMode.ReadOnly">
            <summary>
            Cache is only stored for reading. Write operations are not supported.
            </summary>
        </member>
        <member name="F:Storage.CachedPageStorage.CacheWriteMode.WriteBack">
            <summary>
            Written data will be stored in cache until the buffers are flushed 
            (either automatically or manually via <see cref="M:Storage.CachedPageStorage.Flush"/>).
            </summary>
        </member>
        <member name="F:Storage.CachedPageStorage.CacheWriteMode.WriteThrough">
            <summary>
            All writes are passed directly to the base <see cref="P:Storage.CachedPageStorage.PageStorage"/>.
            There is no need to call <see cref="M:Storage.CachedPageStorage.Flush"/>.
            </summary>
        </member>
        <member name="P:Storage.CachedPageStorage.Mode">
            <summary>
            The <see cref="T:Storage.CachedPageStorage.CacheWriteMode"/> that determines when written data is passed to
            the base <see cref="P:Storage.CachedPageStorage.PageStorage"/>.
            </summary>
        </member>
        <member name="P:Storage.CachedPageStorage.CachedPageIndices">
            <summary>
            Gets the index of each page that is currently cached, in the order such
            that the most recently used page is first.
            </summary>
        </member>
        <member name="P:Storage.CachedPageStorage.IsReadOnly">
            <summary>
            Is this <see cref="T:Storage.CachedPageStorage"/> read-only?
            </summary>
        </member>
        <member name="P:Storage.CachedPageStorage.IsCapacityFixed">
            <summary>
            Is the <see cref="P:Storage.CachedPageStorage.PageCapacity"/> fixed?
            </summary>
            <remarks>
            If <see cref="P:Storage.CachedPageStorage.IsReadOnly"/> is true, then true is returned. Otherwise,
            the return value is equivalent to the <see cref="P:Storage.IPageStorage.IsCapacityFixed"/>
            property of the base <see cref="P:Storage.CachedPageStorage.PageStorage"/>.
            </remarks>
        </member>
        <member name="P:Storage.CachedPageStorage.PageCapacity">
            <summary>
            The total capacity, measured in the number of pages.
            </summary>
            <remarks>
            <para>
            This property refers to the sum of all allocated and unallocated pages. If 
            <see cref="P:Storage.CachedPageStorage.IsCapacityFixed"/> is false, then the page capacity can be 
            increased via <see cref="M:Storage.CachedPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
            and decreased via <see cref="M:Storage.CachedPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>.
            </para>
            </remarks>
            <seealso cref="P:Storage.CachedPageStorage.IsCapacityFixed"/>
            <seealso cref="M:Storage.CachedPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
            <seealso cref="M:Storage.CachedPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
        </member>
        <member name="P:Storage.CachedPageStorage.AllocatedPageCount">
            <summary>
            The total number of pages that are currently allocated.
            </summary>
            <seealso cref="P:Storage.CachedPageStorage.PageCapacity"/>
            <seealso cref="M:Storage.CachedPageStorage.TryAllocatePage(System.Int64@)"/>
            <seealso cref="M:Storage.CachedPageStorage.FreePage(System.Int64)"/>
            <remarks>
            Note that this property may potentially be larger than the number of pages
            that have been allocated <em>by the application</em>, since some
            implementations of the base <see cref="T:Storage.IPageStorage"/> may perform some internal 
            page allocations for their various needs. In general, the application is expected 
            to keep track of which pages it has allocated.
            </remarks>
        </member>
        <member name="P:Storage.CachedPageStorage.PageSize">
            <summary>
            The size of each page's payload, measured in bytes.
            </summary>
            <remarks>
            This is equivalent to the base <see cref="P:Storage.CachedPageStorage.PageSize"/>'s <see cref="P:Storage.IPageStorage.PageSize"/>.
            </remarks>
        </member>
        <member name="P:Storage.CachedPageStorage.EntryPageIndex">
            <summary>
            The index of the application-defined 'entry page,' or null.
            </summary>
            <remarks>
            <para>
            This is equivalent to the base <see cref="P:Storage.CachedPageStorage.PageStorage"/>'s <see cref="P:Storage.IPageStorage.EntryPageIndex"/>, it
            will not be cached.
            </para>
            <para>
            This property is intended as a utility for an application. Consider that the application
            initially does not necessarily know where to start 'finding' data. It is not recommended
            that the application simply assumes the 'entry' page is at a constant index such as zero,
            since the interface technically allows pages to be allocated in any order. Instead, the
            application is expected to store the 'entry page' index in this property. Then, when the
            application first initializes, it will open the 'entry page' specified by this property,
            and that 'entry page' will contain whatever the application needs for initialization.
            </para>
            <para>
            For an example of how this property is useful, consider that the application is storing a
            tree in the storage, where each allocated page is a node. When the application is initialized,
            it will need to know where the root node's page is located. The application would use this property
            to store the index of the root node's page.
            </para>
            <para>
            This property can be used to store any non-negative value, even if it does not refer to an
            allocated page, or null. It is the application's responsibility to avoid assigning an invalid
            index.
            </para>
            <para>
            If a negative value is assigned, an <see cref="T:System.ArgumentOutOfRangeException"/> will be thrown.
            </para>
            <para>
            If <see cref="P:Storage.CachedPageStorage.IsReadOnly"/> is true and the application assigns a value to this property, then
            an <see cref="T:System.InvalidOperationException"/> will be thrown.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when assigning a negative value.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when assigning a value when <see cref="P:Storage.CachedPageStorage.IsReadOnly"/>
            is true.</exception>
        </member>
        <member name="M:Storage.CachedPageStorage.#ctor(Storage.IPageStorage,Storage.CachedPageStorage.CacheWriteMode,System.Int32,System.Boolean)">
            <summary>
            <see cref="T:Storage.CachedPageStorage"/> constructor.
            </summary>
            <param name="baseStorage">The base <see cref="T:Storage.IPageStorage"/>.</param>
            <param name="cacheWriteMode">The <see cref="T:Storage.CachedPageStorage.CacheWriteMode"/> that determines when write operations are
            sent to the <paramref name="baseStorage"/>.</param>
            <param name="cachedPageCapacity">The maximum number of pages to store in cache at once.</param>
            <param name="leaveBaseStorageOpen">Should the <paramref name="baseStorage"/> remain open (non-disposed)
            after this <see cref="T:Storage.CachedPageStorage"/> is disposed? If false, then when <see cref="M:Storage.CachedPageStorage.Dispose"/>
            is called, the <paramref name="baseStorage"/> will also be disposed.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="baseStorage"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="baseStorage"/>'s <see cref="P:Storage.IPageStorage.PageSize"/>
            is greater than <see cref="F:System.Int32.MaxValue"/>, or if <paramref name="cacheWriteMode"/> is not equal to
            <see cref="F:Storage.CachedPageStorage.CacheWriteMode.ReadOnly"/> when the <paramref name="baseStorage"/> is read-only.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="cachedPageCapacity"/> is less
            than zero.</exception>
            <remarks>
            The application should expect that <paramref name="cachedPageCapacity"/> full pages will be loaded into
            memory at any given moment. The amount of memory required depends on the <see cref="P:Storage.IPageStorage.PageSize"/>
            of the <paramref name="baseStorage"/>. If the page size is very high, and so is <paramref name="cachedPageCapacity"/>,
            then there may not be enough memory for the cache. If allocation fails due to an <see cref="T:System.OutOfMemoryException"/>,
            then some pages may be evicted from cache, or cache may be bypassed entirely (by writing to and reading from the
            base <see cref="P:Storage.CachedPageStorage.PageStorage"/> directly, if necessary).
            </remarks>
        </member>
        <member name="M:Storage.CachedPageStorage.Flush">
            <summary>
            Sends all pending write operations to the base <see cref="P:Storage.CachedPageStorage.PageStorage"/>.
            </summary>
            <remarks>
            This method is only necessary when using <see cref="F:Storage.CachedPageStorage.CacheWriteMode.WriteBack"/>.
            If <see cref="P:Storage.CachedPageStorage.Mode"/> is anything other than <see cref="F:Storage.CachedPageStorage.CacheWriteMode.WriteBack"/>, calling
            this method has no effect.
            </remarks>
        </member>
        <member name="M:Storage.CachedPageStorage.EvictPageFromCache(System.Int64)">
            <summary>
            Evicts a page from cache, writing any cached write data to the base <see cref="P:Storage.CachedPageStorage.PageStorage"/>
            if necessary.
            </summary>
            <param name="pageIndex">The index of the page to cache.</param>
            <returns>True if the page was evicted from cache. False indicates
            that it was not cached when this method was called, thus nothing
            changed.</returns>
            <remarks>
            If the <see cref="P:Storage.CachedPageStorage.Mode"/> is <see cref="F:Storage.CachedPageStorage.CacheWriteMode.WriteBack"/>, then any data that has
            been written to the page will be 'flushed' (written) to the base <see cref="P:Storage.CachedPageStorage.PageStorage"/>.
            </remarks>
        </member>
        <member name="M:Storage.CachedPageStorage.IsPageCached(System.Int64)">
            <summary>
            Checks whether a page is currently cached.
            </summary>
            <param name="pageIndex">The index of the page.</param>
            <returns>True if the page at the specified <paramref name="pageIndex"/> is
            currently cached, otherwise false.</returns>
            <remarks>
            If the <paramref name="pageIndex"/> is out of the valid range of pages
            (see <see cref="M:Storage.IPageStorage.IsPageOnStorage(System.Int64)"/>), then false will
            be returned.
            </remarks>
        </member>
        <member name="M:Storage.CachedPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)">
            <summary>
            Attempts to increase the <see cref="P:Storage.CachedPageStorage.PageCapacity"/> of the base <see cref="P:Storage.CachedPageStorage.PageStorage"/>
            by creating space for more unallocated pages.
            </summary>
            <param name="additionalPageCount">The desired additional number of unallocated 
            pages to create.</param>
            <param name="progressReporter"><see cref="T:System.IProgress`1"/> that receives a
            <see cref="T:Storage.ProgressReport"/> as the inflation progresses. May be null, in 
            which case progress will not be reported.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> that allows
            the application to cancel the inflation. Cancellation will cause the inflation
            to stop at the nearest 'safe' position to avoid data corruption. This means
            that some pages may have already been created upon cancellation, but not 
            necessarily as many as were requested. Upon cancellation, this method will
            NOT throw any <see cref="T:System.Exception"/>, but will instead return the additional
            number of pages that have been created, if any, before the operation was
            cancelled.</param>
            <returns>The actual number of additional unallocated pages that were created. 
            This may be more or less than the desired <paramref name="additionalPageCount"/>, 
            and may even be zero.</returns>
            <remarks>
            <para>
            This method will simply call the <see cref="M:Storage.IPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
            method of the base <see cref="P:Storage.CachedPageStorage.PageStorage"/>. Cache will not be affected.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.CachedPageStorage.IsCapacityFixed"/>
            is true.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="additionalPageCount"/>
            is less than zero.</exception>
            <seealso cref="P:Storage.CachedPageStorage.IsCapacityFixed"/>
            <seealso cref="P:Storage.CachedPageStorage.PageCapacity"/>
            <seealso cref="M:Storage.CachedPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Storage.CachedPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)">
            <summary>
            Attempts to decrease the <see cref="P:Storage.CachedPageStorage.PageCapacity"/>, by removing unallocated pages
            at the very end of this <see cref="T:Storage.IPageStorage"/>.
            </summary>
            <param name="removePageCount">The desired number of unallocated pages to remove.</param>
            <param name="progressReporter"><see cref="T:System.IProgress`1"/> that receives a
            <see cref="T:Storage.ProgressReport"/> as the deflation progresses. May be null, in which
            case progress will not be reported.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> that allows the
            application to cancel the deflation operation. Cancellation will cause the
            deflation to stop at the nearest 'safe' position to avoid data corruption. This
            means that some pages may have been removed upon cancellation, but not necessarily
            as many as were requested. Upon cancellation, this method will NOT throw an
            <see cref="T:System.Exception"/>, but will instead return the number of pages that have
            been removed before cancellation.</param>
            <returns>The actual number of unallocated pages that were removed. This may be more or
            less than <paramref name="removePageCount"/>, and may even be zero.</returns>
            <remarks>
            <para>
            This method will simply call the <see cref="M:Storage.IPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
            method of the base <see cref="P:Storage.CachedPageStorage.PageStorage"/>. Cache will not be affected.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.CachedPageStorage.IsCapacityFixed"/>
            is true.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="removePageCount"/>
            is less than zero.</exception>
            <seealso cref="P:Storage.CachedPageStorage.IsCapacityFixed"/>
            <seealso cref="P:Storage.CachedPageStorage.PageCapacity"/>
            <seealso cref="M:Storage.CachedPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Storage.CachedPageStorage.IsPageAllocated(System.Int64)">
            <summary>
            Checks whether a page is currently allocated.
            </summary>
            <param name="index">The index of the page.</param>
            <returns>True if the page is currently allocated, otherwise false.</returns>
            <remarks>
            <para>
            If <paramref name="index"/> is out of the range of all pages (allocated and unallocated),
            then false is returned. See <see cref="M:Storage.CachedPageStorage.IsPageOnStorage(System.Int64)"/>.
            </para>
            <para>
            Note that some base <see cref="P:Storage.CachedPageStorage.PageStorage"/> implementations may perform internal allocations 
            for their various needs, and so this method may return true for such pages. In general, the 
            application should keep track of which pages it has allocated.
            </para>
            </remarks>
            <seealso cref="M:Storage.CachedPageStorage.IsPageOnStorage(System.Int64)"/>
            <seealso cref="M:Storage.CachedPageStorage.TryAllocatePage(System.Int64@)"/>
            <seealso cref="M:Storage.CachedPageStorage.FreePage(System.Int64)"/>
        </member>
        <member name="M:Storage.CachedPageStorage.IsPageOnStorage(System.Int64)">
            <summary>
            Checks whether a page exists (regardless of whether or not it is allocated)
            on the storage.
            </summary>
            <param name="index">The index of the page.</param>
            <returns>True if <paramref name="index"/> is greater than or equal to zero and less
            than <see cref="P:Storage.CachedPageStorage.PageCapacity"/>, otherwise false.</returns>
            <seealso cref="M:Storage.CachedPageStorage.IsPageAllocated(System.Int64)"/>
            <seealso cref="P:Storage.CachedPageStorage.PageCapacity"/>
        </member>
        <member name="M:Storage.CachedPageStorage.TryAllocatePage(System.Int64@)">
            <summary>
            Attempts to allocate a page.
            </summary>
            <param name="index">Upon success, assigned to the index of the allocated page. Upon
            failure, assigned to -1.</param>
            <returns>True if a page was successfully allocated. False only indicates that there
            is no capacity to allocate a new page (<see cref="P:Storage.CachedPageStorage.AllocatedPageCount"/> equals
            <see cref="P:Storage.CachedPageStorage.PageCapacity"/>).</returns>
            <remarks>
            <para>
            This method will simply call the <see cref="M:Storage.CachedPageStorage.TryAllocatePage(System.Int64@)"/> method of
            the base <see cref="P:Storage.CachedPageStorage.PageStorage"/>.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.CachedPageStorage.IsReadOnly"/> is true.</exception>
            <seealso cref="M:Storage.CachedPageStorage.FreePage(System.Int64)"/>
            <seealso cref="P:Storage.CachedPageStorage.IsReadOnly"/>
            <seealso cref="M:Storage.CachedPageStorage.IsPageAllocated(System.Int64)"/>
            <seealso cref="P:Storage.CachedPageStorage.AllocatedPageCount"/>
        </member>
        <member name="M:Storage.CachedPageStorage.FreePage(System.Int64)">
            <summary>
            Deallocates a page.
            </summary>
            <param name="index">The index of the page to deallocate.</param>
            <returns>True if the page was deallocated, false if it was already
            unallocated when this method was called.</returns>
            <remarks>
            <para>
            Before freeing the page, this method will ensure that any pending
            write operations are sent to the base <see cref="P:Storage.CachedPageStorage.PageStorage"/>. This
            may be important for security cases where the application was storing
            sensitive data that it wishes to overwrite before freeing the page. After
            cache is flushed, the <see cref="M:Storage.IPageStorage.FreePage(System.Int64)"/> method of
            the base <see cref="P:Storage.CachedPageStorage.PageStorage"/> will be called.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.CachedPageStorage.IsReadOnly"/> is true.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="index"/> is negative or
            greater than or equal to <see cref="P:Storage.CachedPageStorage.PageCapacity"/>. See <see cref="M:Storage.CachedPageStorage.IsPageOnStorage(System.Int64)"/>.</exception>
            <seealso cref="M:Storage.CachedPageStorage.TryAllocatePage(System.Int64@)"/>
            <seealso cref="P:Storage.CachedPageStorage.IsReadOnly"/>
            <seealso cref="M:Storage.CachedPageStorage.IsPageAllocated(System.Int64)"/>
            <seealso cref="P:Storage.CachedPageStorage.AllocatedPageCount"/>
        </member>
        <member name="M:Storage.CachedPageStorage.ReadFrom(System.Int64,System.Int64,System.Byte[],System.Int64,System.Int64)">
            <summary>
            Reads payload from an allocated page.
            </summary>
            <param name="pageIndex">The index of the allocated page.</param>
            <param name="srcOffset">The source offset within the page's payload, measured in bytes.</param>
            <param name="buffer">The destination buffer.</param>
            <param name="dstOffset">The destination offset within the destination <paramref name="buffer"/>,
            measured in bytes.</param>
            <param name="length">The number of bytes to read.</param>
            <remarks>
            <para>
            If any of the requested data is not currently cached, it will be loaded into cache (unless
            <see cref="P:Storage.CachedPageStorage.CachedPageCapacity"/> is zero). Then, the cached data will be copied into the
            destination <paramref name="buffer"/>. If cache fails due to insufficient memory, or if
            <see cref="P:Storage.CachedPageStorage.CachedPageCapacity"/> is zero, then this method will bypass cache and read
            directly from the base <see cref="P:Storage.CachedPageStorage.PageStorage"/>.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <paramref name="pageIndex"/> does not refer to
            an allocated page.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="srcOffset"/>,
            <paramref name="dstOffset"/>, or <paramref name="length"/> is negative; or if the sum of
            <paramref name="srcOffset"/> and <paramref name="length"/> is greater than <see cref="P:Storage.CachedPageStorage.PageSize"/>;
            or if the sum of <paramref name="dstOffset"/> and <paramref name="length"/> is greater than
            the <paramref name="buffer"/> size.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <seealso cref="M:Storage.CachedPageStorage.WriteTo(System.Int64,System.Int64,System.Byte[],System.Int64,System.Int64)"/>
            <seealso cref="M:Storage.CachedPageStorage.IsPageAllocated(System.Int64)"/>
        </member>
        <member name="M:Storage.CachedPageStorage.WriteTo(System.Int64,System.Int64,System.Byte[],System.Int64,System.Int64)">
            <summary>
            Writes payload to an allocated page.
            </summary>
            <param name="pageIndex">The index of the allocated page.</param>
            <param name="dstOffset">The destination offset within the page's payload, measured in 
            bytes.</param>
            <param name="buffer">The source buffer.</param>
            <param name="srcOffset">The source offset within the source <paramref name="buffer"/>,
            measured in bytes.</param>
            <param name="length">The number of bytes to write.</param>
            <remarks>
            <para>
            If the page is not loaded into cache, it will be loaded (but not read, as read is not
            necessary for this method). The data will be written into the cached page (unless cache
            failed or <see cref="P:Storage.CachedPageStorage.CachedPageCapacity"/> is zero), and then if <see cref="P:Storage.CachedPageStorage.Mode"/> is
            <see cref="F:Storage.CachedPageStorage.CacheWriteMode.WriteThrough"/> the data will also be immediately written to
            the base <see cref="P:Storage.CachedPageStorage.PageStorage"/>. If <see cref="P:Storage.CachedPageStorage.Mode"/> is <see cref="F:Storage.CachedPageStorage.CacheWriteMode.WriteBack"/>,
            then data will be written to the base <see cref="P:Storage.CachedPageStorage.PageStorage"/> at a later time (when the 
            internal buffers get too full, or when the page is evicted from cache, or when <see cref="M:Storage.CachedPageStorage.Flush"/> 
            or <see cref="M:Storage.CachedPageStorage.Dispose"/> is called). If caching fails, or if <see cref="P:Storage.CachedPageStorage.CachedPageCapacity"/>
            is zero, then the data will be immediately written directly to the base <see cref="P:Storage.CachedPageStorage.PageStorage"/> 
            regardless of the <see cref="P:Storage.CachedPageStorage.Mode"/>.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <paramref name="pageIndex"/> refers
            to an unallocated page, or if <see cref="P:Storage.CachedPageStorage.IsReadOnly"/> is true.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="srcOffset"/>,
            <paramref name="dstOffset"/>, or <paramref name="length"/> is negative; or if
            the sum of <paramref name="dstOffset"/> and <paramref name="length"/> is greater
            than <see cref="P:Storage.CachedPageStorage.PageSize"/>; or if the sum of <paramref name="srcOffset"/> and
            <paramref name="length"/> is greater than the <paramref name="buffer"/> size.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <seealso cref="M:Storage.CachedPageStorage.ReadFrom(System.Int64,System.Int64,System.Byte[],System.Int64,System.Int64)"/>
            <seealso cref="P:Storage.CachedPageStorage.IsReadOnly"/>
            <seealso cref="M:Storage.CachedPageStorage.IsPageAllocated(System.Int64)"/>
        </member>
        <member name="P:Storage.CachedPageStorage.IsDisposed">
            <summary>
            Has this <see cref="T:Storage.CachedPageStorage"/> been disposed?
            </summary>
        </member>
        <member name="M:Storage.CachedPageStorage.Dispose">
            <summary>
            Disposes this <see cref="T:Storage.CachedPageStorage"/>, sending any cached write operations
            to the base <see cref="P:Storage.CachedPageStorage.PageStorage"/>.
            </summary>
            <remarks>
            <para>
            This method will result in a call to <see cref="M:Storage.CachedPageStorage.Flush"/> to ensure that any cached write
            operations are sent to the base <see cref="P:Storage.CachedPageStorage.PageStorage"/>.
            </para>
            <para>
            If <see cref="P:Storage.CachedPageStorage.WillLeaveBasePageStorageOpen"/> is false, then this method will dispose the
            base <see cref="P:Storage.CachedPageStorage.PageStorage"/>.
            </para>
            </remarks>
            <seealso cref="P:Storage.CachedPageStorage.IsDisposed"/>
        </member>
        <member name="T:Storage.Data.BTree`2">
            <summary>
            Base class for a B-Tree.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <remarks>
            Note that the application cannot interact with the <see cref="T:Storage.Data.BTreeNode`2"/>s
            of a <see cref="T:Storage.Data.BTree`2"/> directly. The application can read the <see cref="T:Storage.Data.BTreeNode`2"/>
            of a <see cref="T:Storage.Data.BTree`2"/> by using a <see cref="T:Storage.Data.BTreeReader`2"/> only when
            the <see cref="T:Storage.Data.BTree`2"/> is read-only.
            </remarks>
        </member>
        <member name="P:Storage.Data.BTree`2.PageStorage">
            <summary>
            The <see cref="T:Storage.IPageStorage"/> on which this <see cref="T:Storage.Data.BTree`2"/>
            is stored.
            </summary>
        </member>
        <member name="P:Storage.Data.BTree`2.IsReadOnly">
            <summary>
            Is this <see cref="T:Storage.Data.BTree`2"/> read-only?
            </summary>
        </member>
        <member name="P:Storage.Data.BTree`2.KeySerializer">
            <summary>
            The <see cref="T:Storage.Data.Serializers.ISerializer`1"/> that is used to serialize and
            deserialize the keys.
            </summary>
        </member>
        <member name="P:Storage.Data.BTree`2.ValueSerializer">
            <summary>
            The <see cref="T:Storage.Data.Serializers.ISerializer`1"/> that is used to serialize and
            deserialize the values.
            </summary>
        </member>
        <member name="P:Storage.Data.BTree`2.Count">
            <summary>
            The number of key-value pairs that are stored in this <see cref="T:Storage.Data.BTree`2"/>.
            </summary>
        </member>
        <member name="P:Storage.Data.BTree`2.RootPageIndex">
            <summary>
            The index on the <see cref="P:Storage.Data.BTree`2.PageStorage"/> where the root <see cref="T:Storage.Data.BTreeNode`2"/>
            is stored, or null if there is no root node.
            </summary>
            <seealso cref="P:Storage.Data.BTree`2.Root"/>
        </member>
        <member name="P:Storage.Data.BTree`2.Root">
            <summary>
            The root <see cref="T:Storage.Data.BTreeNode`2"/>, or null.
            </summary>
        </member>
        <member name="M:Storage.Data.BTree`2.#ctor(Storage.IPageStorage,Storage.Data.Serializers.ISerializer{`0},Storage.Data.Serializers.ISerializer{`1},System.Int64)">
            <summary>
            <see cref="T:Storage.Data.BTree`2"/> constructor.
            </summary>
            <param name="pageStorage">The <see cref="T:Storage.IPageStorage"/> on which this <see cref="T:Storage.Data.BTree`2"/> is
            stored or will be stored.</param>
            <param name="keySerializer">The <see cref="T:Storage.Data.Serializers.ISerializer`1"/> that will be used to serialize and
            deserialize the keys.</param>
            <param name="valueSerializer">The <see cref="T:Storage.Data.Serializers.ISerializer`1"/> that will be used to serialize and
            deserialize the values.</param>
            <param name="maxMovePairCount">The maximum size of the internal buffer that may be used to move key-value
            pairs during certain operations such as insertions, measured in the number of key-value pairs. Must be
            at least one.</param>
            <remarks>
            <para>
            Note that the <paramref name="pageStorage"/>'s pages must be sufficiently large to store a <see cref="T:Storage.Data.BTreeNode`2"/>
            with several key-value pairs. The very minimum key-value pair capacity is <see cref="F:Storage.Data.BTreeNode`2.VeryMinKeyValuePairCapacity"/>,
            but most applications should use a significantly larger capacity. To determine the key-value pair capacity for a given
            page size, see <see cref="M:Storage.Data.BTreeNode`2.GetRequiredPageSize(System.Int64,System.Int64,System.Int64)"/>. The 'key size' and
            'value size' are defined by the <see cref="P:Storage.Data.Serializers.ISerializer`1.DataSize"/> of the <paramref name="keySerializer"/>
            and <paramref name="valueSerializer"/>.
            </para>
            <para>
            During some operations, such as insertions, some <see cref="T:Storage.Data.BTreeNode`2"/>s may have to move around some
            of their key-value pairs. In most cases, it will be more efficient if several key-value pairs are moved at once
            (rather than one at a time). The <paramref name="maxMovePairCount"/> argument defines the maximum number of
            key-value pairs that will be moved at once. A larger number should result in improved speed, but at the cost
            of increased runtime memory. The size, in bytes, of the internal buffer is approximately the size of the
            binary-serialized keys and values (see <see cref="P:Storage.Data.Serializers.ISerializer`1.DataSize"/> for <paramref name="keySerializer"/>
            and <paramref name="valueSerializer"/>) plus eight bytes of overhead, all multiplied by the <paramref name="maxMovePairCount"/> 
            argument.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="pageStorage"/>, <paramref name="keySerializer"/>,
            or <paramref name="valueSerializer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="maxMovePairCount"/> is less than one.</exception>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="pageStorage"/>'s pages are too small to contain
            a <see cref="T:Storage.Data.BTreeNode`2"/> with <see cref="F:Storage.Data.BTreeNode`2.VeryMinKeyValuePairCapacity"/>
            key-value pairs. See <see cref="M:Storage.Data.BTreeNode`2.GetKeyValuePairCapacityForPageSize(System.Int64,System.Int64,System.Int64)"/>
            and <see cref="M:Storage.Data.BTreeNode`2.GetRequiredPageSize(System.Int64,System.Int64,System.Int64)"/>.</exception>
        </member>
        <member name="M:Storage.Data.BTree`2.TryGetValue(`0,`1@,System.Threading.CancellationToken)">
            <summary>
            Attempts to get the value that is associated to a particular key in this <see cref="T:Storage.Data.BTree`2"/>.
            </summary>
            <param name="key">The key.</param>
            <param name="valueOrDefault">Assigned to the value that is associated to the <paramref name="key"/>, or
            the default <typeparamref name="TValue"/> value if there is no value associated to the <paramref name="key"/>.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> that can be used to cancel the search
            operation. Upon cancellation, false is returned.</param>
            <returns>True if the value was found, otherwise false. False indicates that the <paramref name="key"/> was not
            present in this <see cref="T:Storage.Data.BTree`2"/>, or that the search was cancelled via the
            <paramref name="cancellationToken"/>.</returns>
        </member>
        <member name="M:Storage.Data.BTree`2.ContainsKey(`0,System.Threading.CancellationToken)">
            <summary>
            Checks whether this <see cref="T:Storage.Data.BTree`2"/> contains a specific key.
            </summary>
            <param name="key">The key to find.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> that can be used to cancel the search
            operation. Upon cancellation, false is returned.</param>
            <returns>True if the <paramref name="key"/> was found in this <see cref="T:Storage.Data.BTree`2"/>. False
            indicates that it is not stored in this <see cref="T:Storage.Data.BTree`2"/>, or that the search operation
            was cancelled via the <paramref name="cancellationToken"/>.</returns>
        </member>
        <member name="M:Storage.Data.BTree`2.Insert(`0,`1,System.Boolean,System.Boolean@)">
            <summary>
            Inserts a new key-value pair to this <see cref="T:Storage.Data.BTree`2"/>, or optionally updates an existing
            one.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <param name="updateIfExists">If this <see cref="T:Storage.Data.BTree`2"/> already contains a key-value pair
            with the specified <paramref name="key"/>, should it be updated?</param>
            <param name="alreadyExists">Assigned to true if the <paramref name="key"/> was already present in this
            <see cref="T:Storage.Data.BTree`2"/>, otherwise false.</param>
            <returns>True if any change was made, otherwise false. False indicates that the insertion was rejected
            because the <paramref name="key"/> is already stored in this <see cref="T:Storage.Data.BTree`2"/> while
            <paramref name="updateIfExists"/> is false, or the insertion failed due to an allocation failure 
            (when <see cref="M:Storage.IPageStorage.TryAllocatePage(System.Int64@)"/> returns false).</returns>
            <remarks>
            <para>
            This method may split any <see cref="T:Storage.Data.BTreeNode`2"/>s that are discovered to be at
            full capacity (<see cref="P:Storage.Data.BTreeNode`2.MaxKeyValuePairCapacity"/>) [often called
            'preemptive split' or 'proactive insertion']. Even if false is returned (due to insertion 
            rejection, or allocation failure), some <see cref="T:Storage.Data.BTreeNode`2"/>s may have been 
            split. This will <em>not</em> have any effect on the correctness of the 
            <see cref="T:Storage.Data.BTree`2"/> or any data that is stored in it. When false is returned, the 
            caller can be confident that all stored key-value pairs are unchanged, though they may have 
            internally moved between <see cref="T:Storage.Data.BTreeNode`2"/>s (a result of splitting).
            </para>
            <para>
            Insertion may sometimes require a new <see cref="T:Storage.Data.BTreeNode`2"/> to be allocated on the
            <see cref="P:Storage.Data.BTree`2.PageStorage"/>. If the <see cref="P:Storage.Data.BTree`2.PageStorage"/> is at full capacity (<see cref="P:Storage.IPageStorage.PageCapacity"/>),
            then inflation may be required to insert a new key-value pair. This method will automatically try to inflate
            the <see cref="P:Storage.Data.BTree`2.PageStorage"/> by one page when necessary (unless <see cref="P:Storage.IPageStorage.IsCapacityFixed"/>
            is true) via the <see cref="M:Storage.IPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/> method.
            If allocation or inflation fails (or <see cref="P:Storage.IPageStorage.IsCapacityFixed"/> is true when inflation is
            necessary), then it may not be possible to insert certain <em>new</em> key-value pairs (depending on the 
            value of the <paramref name="key"/> and the current structure of the B-Tree). However, even if inflation 
            or allocation fails, it will be possible to update the value associated to an <em>existing</em> 
            <paramref name="key"/>.
            </para>
            <para>
            If any <see cref="T:System.Exception"/> is thrown (except the <see cref="T:System.InvalidOperationException"/> mentioned
            in this document), then the application should assume that data may have been corrupted.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.Data.BTree`2.IsReadOnly"/> is true or if this method
            was called from within a <see cref="M:Storage.Data.BTree`2.Traverse(System.Boolean)"/> enumeration.</exception>
        </member>
        <member name="M:Storage.Data.BTree`2.Remove(`0,`1@)">
            <summary>
            Removes a key-value pair from this <see cref="T:Storage.Data.BTree`2"/>.
            </summary>
            <param name="key">The key that defines the key-value pair to remove.</param>
            <param name="valueOrDefault">Upon removal, assigned to the value that was removed. Otherwise
            assigned to the default <typeparamref name="TValue"/> value.</param>
            <returns>True if the key-value pair was removed. False indicates that the <paramref name="key"/>
            was not present in this <see cref="T:Storage.Data.BTree`2"/>.</returns>
            <remarks>
            <para>
            Even though the <see cref="M:Storage.Data.BTree`2.Insert(`0,`1,System.Boolean,System.Boolean@)"/>
            method may inflate the <see cref="P:Storage.Data.BTree`2.PageStorage"/> if necessary, this method will never deflate it.
            </para>
            <para>
            If any <see cref="T:System.Exception"/> is thrown (except the <see cref="T:System.InvalidOperationException"/> mentioned
            in this document), then the application should assume that data may have been corrupted.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.Data.BTree`2.IsReadOnly"/> is true or if this method 
            was called from within a <see cref="M:Storage.Data.BTree`2.Traverse(System.Boolean)"/> enumeration.</exception>
        </member>
        <member name="M:Storage.Data.BTree`2.Traverse(System.Boolean)">
            <summary>
            Traverses through all <see cref="T:System.Collections.Generic.KeyValuePair`2"/>s in this <see cref="T:Storage.Data.BTree`2"/>.
            </summary>
            <param name="ascending">Should the pairs be enumerated by ascending key order? If false, descending
            key order will be used.</param>
            <returns>All <see cref="T:System.Collections.Generic.KeyValuePair`2"/>s.</returns>
        </member>
        <member name="M:Storage.Data.BTree`2.Validate(System.Threading.CancellationToken)">
            <summary>
            Traverses through the entire structure of this <see cref="T:Storage.Data.BTree`2"/>, searching for
            any indications of corrupt data.
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> that can be used to cancel the
            validation operation.</param>
            <remarks>
            <para>
            <see cref="P:Storage.Data.BTree`2.IsReadOnly"/> must be true when calling this method, since validation requires the state
            to remain unchanged during the entire process.
            </para>
            <para>
            Note that this operation should be expected to be slow, as it must traverse through the entire
            tree structure several times. While validation is being performed, it is still possible to
            perform read operations on this <see cref="T:Storage.Data.BTree`2"/> on a different thread.
            </para>
            <para>
            If this method returns, then no corruption has been detected. When corruption is detected, this
            method will throw a <see cref="T:Storage.Data.CorruptDataException"/>. Note that this method may not detect
            all possible forms of corruption.
            </para>
            </remarks>
            <exception cref="T:Storage.Data.CorruptDataException">Thrown if any corrupt data is found.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.Data.BTree`2.IsReadOnly"/> is false.</exception>
        </member>
        <member name="T:Storage.Data.BTreeNode`2">
            <summary>
            Stores several key-value pairs and references to sub-trees for a B-Tree node.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="F:Storage.Data.BTreeNode`2.VeryMinKeyValuePairCapacity">
            <summary>
            The minimum capacity of a <see cref="T:Storage.Data.BTreeNode`2"/>, measured in the
            number of key-value pairs.
            </summary>
            <remarks>
            In practice, using a <see cref="T:Storage.Data.BTreeNode`2"/> with this capacity is
            likely to be woefully inefficient.
            </remarks>
        </member>
        <member name="M:Storage.Data.BTreeNode`2.GetRequiredPageSize(System.Int64,System.Int64,System.Int64)">
            <summary>
            Gets the minimum size of an <see cref="T:Storage.IPageStorage"/> that is required to store a specific
            capacity of key-value pairs.
            </summary>
            <param name="keySize">The size, in bytes, of the binary-serialized key. Must be at least
            one byte.</param>
            <param name="valueSize">The size, in bytes, of the binary-serialized value. Cannot be less
            than zero.</param>
            <param name="keyValuePairCapacity">The desired key-value pair capacity. This is the
            maximum number of key-value pairs that can be stored in the <see cref="T:Storage.Data.BTreeNode`2"/>.
            Must be at least <see cref="F:Storage.Data.BTreeNode`2.VeryMinKeyValuePairCapacity"/>, and must be an odd number.</param>
            <returns>The required page size, measured in bytes.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="keySize"/> is less than
            one, if <paramref name="valueSize"/> is less than zero, or if <paramref name="keyValuePairCapacity"/>
            is less than <see cref="F:Storage.Data.BTreeNode`2.VeryMinKeyValuePairCapacity"/>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="keyValuePairCapacity"/> is not an odd 
            number.</exception>
            <seealso cref="F:Storage.Data.BTreeNode`2.VeryMinKeyValuePairCapacity"/>
            <seealso cref="M:Storage.Data.BTreeNode`2.GetKeyValuePairCapacityForPageSize(System.Int64,System.Int64,System.Int64)"/>
        </member>
        <member name="M:Storage.Data.BTreeNode`2.GetKeyValuePairCapacityForPageSize(System.Int64,System.Int64,System.Int64)">
            <summary>
            Gets the capacity of a <see cref="T:Storage.Data.BTreeNode`2"/> that can be stored on a page of a specific size.
            </summary>
            <param name="pageSize">The size, in bytes, of the page.</param>
            <param name="keySize">The size, in bytes, of the binary-serialized key. Cannot be less than
            one.</param>
            <param name="valueSize">The size, in bytes, of the binary-serialized value. Cannot be less
            than zero.</param>
            <returns>The maximum number of key-value pairs that can be stored in a <see cref="T:Storage.Data.BTreeNode`2"/>
            that is stored on a page of the specified <paramref name="pageSize"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="keySize"/> is less than
            one, or <paramref name="valueSize"/> is less than zero.</exception>
            <remarks>
            If the <paramref name="pageSize"/> is not sufficient for the minimum possible key-value pair
            capacity (see <see cref="F:Storage.Data.BTreeNode`2.VeryMinKeyValuePairCapacity"/>), then zero is returned. Also note that
            a <see cref="T:Storage.Data.BTreeNode`2"/>'s key-value pair capacity must be an odd number. So if
            the <paramref name="pageSize"/> could theoretically store an even number of key-value pairs, this
            method will subtract one to enforce the odd number requirement.
            </remarks>
            <seealso cref="F:Storage.Data.BTreeNode`2.VeryMinKeyValuePairCapacity"/>
            <seealso cref="M:Storage.Data.BTreeNode`2.GetRequiredPageSize(System.Int64,System.Int64,System.Int64)"/>
        </member>
        <member name="P:Storage.Data.BTreeNode`2.PageIndex">
            <summary>
            The index on the <see cref="T:Storage.IPageStorage"/> where this <see cref="T:Storage.Data.BTreeNode`2"/>
            is stored.
            </summary>
        </member>
        <member name="P:Storage.Data.BTreeNode`2.BTree">
            <summary>
            The <see cref="T:Storage.Data.BTree`2"/> to which this <see cref="T:Storage.Data.BTreeNode`2"/> belongs.
            </summary>
        </member>
        <member name="P:Storage.Data.BTreeNode`2.MaxKeyValuePairCapacity">
            <summary>
            The maximum number of key-value pairs that can be stored in this <see cref="T:Storage.Data.BTreeNode`2"/>.
            </summary>
            <seealso cref="M:Storage.Data.BTreeNode`2.GetKeyValuePairCapacityForPageSize(System.Int64,System.Int64,System.Int64)"/>
        </member>
        <member name="P:Storage.Data.BTreeNode`2.MinKeyValuePairCapacity">
            <summary>
            The minimum number of key-value pairs that can be stored in this <see cref="T:Storage.Data.BTreeNode`2"/> (unless
            this is the root node).
            </summary>
            <remarks>
            This property does <em>not</em> apply to the root node of the <see cref="T:Storage.Data.BTree`2"/>, which
            can have as few as necessary.
            </remarks>
        </member>
        <member name="P:Storage.Data.BTreeNode`2.KeyValuePairCount">
            <summary>
            The number of key-value pairs that are currently stored in this <see cref="T:Storage.Data.BTreeNode`2"/>.
            </summary>
        </member>
        <member name="P:Storage.Data.BTreeNode`2.SubTreeCount">
            <summary>
            The number of sub-trees that are stored in this <see cref="T:Storage.Data.BTreeNode`2"/>.
            </summary>
            <remarks>
            For non-leaf nodes, this is <see cref="P:Storage.Data.BTreeNode`2.KeyValuePairCount"/>+1. For leaf nodes, this
            is zero (since leaf nodes have no sub-trees).
            </remarks>
        </member>
        <member name="P:Storage.Data.BTreeNode`2.IsLeaf">
            <summary>
            Is this <see cref="T:Storage.Data.BTreeNode`2"/> a leaf node?
            </summary>
        </member>
        <member name="F:Storage.Data.BTreeNode`2.locker">
            <summary>
            Arbitrary object for locking.
            </summary>
            <remarks>
            Note that this lock object will not protect against multiple <see cref="T:Storage.Data.BTreeNode`2"/>
            instances referencing the same page on the <see cref="T:Storage.IPageStorage"/>. However, the tree implementation
            (<see cref="T:Storage.Data.BTree`2"/> and <see cref="T:Storage.Data.BTreeNode`2"/> internally) will take care
            to avoid multiple instances. And the application can only instantiate read-only <see cref="T:Storage.Data.BTreeNode`2"/>s
            via a <see cref="T:Storage.Data.BTreeReader`2"/>, thus preventing any conflict.
            </remarks>
        </member>
        <member name="M:Storage.Data.BTreeNode`2.GetKeyAt(System.Int64)">
            <summary>
            Gets a key that is stored at a particular index on this <see cref="T:Storage.Data.BTreeNode`2"/>.
            </summary>
            <param name="index">The index of the key.</param>
            <returns>The key at the specified <paramref name="index"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="index"/> is less than
            zero or greater than or equal to <see cref="P:Storage.Data.BTreeNode`2.KeyValuePairCount"/>.</exception>
            <remarks>
            Keys are stored in ascending order.
            </remarks>
        </member>
        <member name="P:Storage.Data.BTreeNode`2.Keys">
            <summary>
            All keys stored in this <see cref="T:Storage.Data.BTreeNode`2"/>, in ascending order.
            </summary>
        </member>
        <member name="M:Storage.Data.BTreeNode`2.GetValueAt(System.Int64)">
            <summary>
            Gets the value that is stored at a particular index on this <see cref="T:Storage.Data.BTreeNode`2"/>.
            </summary>
            <param name="index">The index of the value.</param>
            <returns>The value at the specified <paramref name="index"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="index"/> is less than
            zero or greater than or equal to <see cref="P:Storage.Data.BTreeNode`2.KeyValuePairCount"/>.</exception>
        </member>
        <member name="P:Storage.Data.BTreeNode`2.Values">
            <summary>
            All values stored in this <see cref="T:Storage.Data.BTreeNode`2"/>, in the order determined by
            the associated key.
            </summary>
        </member>
        <member name="M:Storage.Data.BTreeNode`2.GetEnumerator">
            <summary>
            Enumerates through all key-value pairs in this <see cref="T:Storage.Data.BTreeNode`2"/>.
            </summary>
            <returns>An enumeration of all key-value pairs, in ascending key order.</returns>
            <remarks>
            This method will <em>not</em> enumerate the key-value pairs that are stored in sub-trees.
            </remarks>
        </member>
        <member name="M:Storage.Data.BTreeNode`2.TryFindKeyIndexOrSubTreeIndexForKey(`0,System.Int64@,System.Boolean@,System.Int64@)">
            <summary>
            Attempts to find the index of a <paramref name="key"/> on this <see cref="T:Storage.Data.BTreeNode`2"/>, or the index
            of a sub-tree that <em>may</em> contain the <paramref name="key"/>.
            </summary>
            <param name="key">The input <typeparamref name="TKey"/>.</param>
            <param name="indexOnThisNode">If the <paramref name="key"/> was found on this <see cref="T:Storage.Data.BTreeNode`2"/> (check return
            value), then this argument will be assigned to the index of the <paramref name="key"/>. Otherwise, -1 will be assigned.</param>
            <param name="mayBeFoundInSubTree">Assigned to true if the <paramref name="key"/> <em>might</em> be found on one of
            this <see cref="T:Storage.Data.BTreeNode`2"/>'s sub-trees, otherwise false.</param>
            <param name="mayBeFoundInSubTreeIndex">If <paramref name="mayBeFoundInSubTree"/> is true, assigned to the index of the
            sub-tree that <em>might</em> contain the <paramref name="key"/>. Otherwise, -1 will be assigned.</param>
            <returns>True if the <paramref name="key"/> was found on this <see cref="T:Storage.Data.BTreeNode`2"/>, otherwise false.</returns>
        </member>
        <member name="M:Storage.Data.BTreeNode`2.SplitSubTreeAt(System.Int64,Storage.Data.BTreeNode{`0,`1})">
            <summary>
            Splits a sub-tree at a specific index, and moves the 'middle' value up to this <see cref="T:Storage.Data.BTreeNode`2"/>.
            </summary>
            <param name="index">The index of the sub-tree to split. The <see cref="T:Storage.Data.BTreeNode`2"/> at
            this sub-tree index must be full (<see cref="P:Storage.Data.BTreeNode`2.KeyValuePairCount"/> must be equal to <see cref="P:Storage.Data.BTreeNode`2.MaxKeyValuePairCapacity"/>).
            This index is also the index where the 'middle' key-value pair will be inserted to this 
            <see cref="T:Storage.Data.BTreeNode`2"/>.</param>
            <param name="newNode">An empty <see cref="T:Storage.Data.BTreeNode`2"/> that will become the
            'right' portion of the split node.</param>
            <remarks>
            This method must only be called when the sub-tree root <see cref="T:Storage.Data.BTreeNode`2"/> at the specified
            <paramref name="index"/> is full (meaning its <see cref="P:Storage.Data.BTreeNode`2.KeyValuePairCount"/> is equal to <see cref="P:Storage.Data.BTreeNode`2.MaxKeyValuePairCapacity"/>).
            This method will 'break' that node into two larger pieces, and a 'middle' value. The left half of that
            'broken' node will remain unchanged. But the 'right' half will be moved into <paramref name="newNode"/>. And
            the 'middle' will ascend into this <see cref="T:Storage.Data.BTreeNode`2"/>, inserted at <paramref name="index"/>.
            </remarks>
        </member>
        <member name="T:Storage.Data.BTreeReader`2">
            <summary>
            Class that allows the application to observe the <see cref="T:Storage.Data.BTreeNode`2"/> structure
            of a <see cref="T:Storage.Data.BTree`2"/>.
            </summary>
            <typeparam name="TKey">The key type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
        </member>
        <member name="P:Storage.Data.BTreeReader`2.BTree">
            <summary>
            The <see cref="T:Storage.Data.BTree`2"/> from which this <see cref="T:Storage.Data.BTreeReader`2"/>
            reads.
            </summary>
        </member>
        <member name="M:Storage.Data.BTreeReader`2.#ctor(Storage.Data.BTree{`0,`1})">
            <summary>
            <see cref="T:Storage.Data.BTreeReader`2"/> constructor.
            </summary>
            <param name="bTree">The <see cref="T:Storage.Data.BTree`2"/>. Must be read-only.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="bTree"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="bTree"/> is not read-only. See
            <see cref="P:Storage.Data.BTree`2.IsReadOnly"/>.</exception>
        </member>
        <member name="P:Storage.Data.BTreeReader`2.RootNode">
            <summary>
            The root <see cref="T:Storage.Data.BTreeNode`2"/>, or null if the <see cref="P:Storage.Data.BTreeReader`2.BTree"/> is empty.
            </summary>
        </member>
        <member name="T:Storage.Data.Binary">
            <summary>
            Static class for binary storage methods.
            </summary>
        </member>
        <member name="M:Storage.Data.Binary.GetInt16Bytes(System.Int16,System.Boolean)">
            <summary>
            Converts an <see cref="T:System.Int16"/> to a byte array.
            </summary>
            <param name="value">The <see cref="T:System.Int16"/> value.</param>
            <param name="littleEndian">Should the bytes be ordered in little-endian? If false, big endian is used.</param>
            <returns>The two bytes.</returns>
        </member>
        <member name="M:Storage.Data.Binary.GetUInt16Bytes(System.UInt16,System.Boolean)">
            <summary>
            Converts an <see cref="T:System.UInt16"/> to a byte array.
            </summary>
            <param name="value">The <see cref="T:System.UInt16"/> value.</param>
            <param name="littleEndian">Should the bytes be ordered in little-endian? If false, big endian is used.</param>
            <returns>The two bytes.</returns>
        </member>
        <member name="M:Storage.Data.Binary.ReadInt16(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Reads an <see cref="T:System.Int16"/> from a byte array.
            </summary>
            <param name="buffer">The buffer containing the value.</param>
            <param name="offset">The position in the <paramref name="buffer"/> of the first byte to read.</param>
            <param name="littleEndian">Should the bytes be interpreted as little-endian? If false, big endian is used.</param>
            <returns>The resulting value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="offset"/> is invalid (accounting for
            the size of an <see cref="T:System.Int16"/>).</exception>
        </member>
        <member name="M:Storage.Data.Binary.ReadUInt16(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Reads an <see cref="T:System.UInt16"/> from a byte array.
            </summary>
            <param name="buffer">The buffer containing the value.</param>
            <param name="offset">The position in the <paramref name="buffer"/> of the first byte to read.</param>
            <param name="littleEndian">Should the bytes be interpreted as little-endian? If false, big endian is used.</param>
            <returns>The resulting value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="offset"/> is invalid (accounting for
            the size of an <see cref="T:System.UInt16"/>).</exception>
        </member>
        <member name="M:Storage.Data.Binary.GetInt32Bytes(System.Int32,System.Boolean)">
            <summary>
            Converts an <see cref="T:System.Int32"/> to a byte array.
            </summary>
            <param name="value">The <see cref="T:System.Int32"/> value.</param>
            <param name="littleEndian">Should the bytes be ordered in little-endian? If false, big endian is used.</param>
            <returns>The four bytes.</returns>
        </member>
        <member name="M:Storage.Data.Binary.GetUInt32Bytes(System.UInt32,System.Boolean)">
            <summary>
            Converts an <see cref="T:System.UInt32"/> to a byte array.
            </summary>
            <param name="value">The <see cref="T:System.UInt32"/> value.</param>
            <param name="littleEndian">Should the bytes be ordered in little-endian? If false, big endian is used.</param>
            <returns>The four bytes.</returns>
        </member>
        <member name="M:Storage.Data.Binary.ReadInt32(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Reads an <see cref="T:System.Int32"/> from a byte array.
            </summary>
            <param name="buffer">The buffer containing the value.</param>
            <param name="offset">The position in the <paramref name="buffer"/> of the first byte to read.</param>
            <param name="littleEndian">Should the bytes be interpreted as little-endian? If false, big endian is used.</param>
            <returns>The resulting value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="offset"/> is invalid (accounting for
            the size of an <see cref="T:System.Int16"/>).</exception>
        </member>
        <member name="M:Storage.Data.Binary.ReadUInt32(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Reads an <see cref="T:System.UInt32"/> from a byte array.
            </summary>
            <param name="buffer">The buffer containing the value.</param>
            <param name="offset">The position in the <paramref name="buffer"/> of the first byte to read.</param>
            <param name="littleEndian">Should the bytes be interpreted as little-endian? If false, big endian is used.</param>
            <returns>The resulting value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="offset"/> is invalid (accounting for
            the size of an <see cref="T:System.Int16"/>).</exception>
        </member>
        <member name="M:Storage.Data.Binary.GetInt64Bytes(System.Int64,System.Boolean)">
            <summary>
            Converts an <see cref="T:System.Int64"/> to a byte array.
            </summary>
            <param name="value">The <see cref="T:System.Int64"/> value.</param>
            <param name="littleEndian">Should the bytes be ordered in little-endian? If false, big endian is used.</param>
            <returns>The eight bytes.</returns>
        </member>
        <member name="M:Storage.Data.Binary.GetUInt64Bytes(System.UInt64,System.Boolean)">
            <summary>
            Converts an <see cref="T:System.UInt64"/> to a byte array.
            </summary>
            <param name="value">The <see cref="T:System.UInt64"/> value.</param>
            <param name="littleEndian">Should the bytes be ordered in little-endian? If false, big endian is used.</param>
            <returns>The eight bytes.</returns>
        </member>
        <member name="M:Storage.Data.Binary.ReadInt64(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Reads an <see cref="T:System.Int64"/> from a byte array.
            </summary>
            <param name="buffer">The buffer containing the value.</param>
            <param name="offset">The position in the <paramref name="buffer"/> of the first byte to read.</param>
            <param name="littleEndian">Should the bytes be interpreted as little-endian? If false, big endian is used.</param>
            <returns>The resulting value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="offset"/> is invalid (accounting for
            the size of an <see cref="T:System.Int16"/>).</exception>
        </member>
        <member name="M:Storage.Data.Binary.ReadUInt64(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Reads an <see cref="T:System.UInt64"/> from a byte array.
            </summary>
            <param name="buffer">The buffer containing the value.</param>
            <param name="offset">The position in the <paramref name="buffer"/> of the first byte to read.</param>
            <param name="littleEndian">Should the bytes be interpreted as little-endian? If false, big endian is used.</param>
            <returns>The resulting value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="offset"/> is invalid (accounting for
            the size of an <see cref="T:System.Int16"/>).</exception>
        </member>
        <member name="M:Storage.Data.Binary.GetSingleBytes(System.Single,System.Boolean)">
            <summary>
            Converts a <see cref="T:System.Single"/> to a byte array.
            </summary>
            <param name="value">The <see cref="T:System.Single"/> value.</param>
            <param name="littleEndian">Should the bytes be ordered in little-endian? If false, big endian is used.</param>
            <returns>The four bytes.</returns>
        </member>
        <member name="M:Storage.Data.Binary.ReadSingle(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Reads a <see cref="T:System.Single"/> from a byte array.
            </summary>
            <param name="buffer">The buffer containing the value.</param>
            <param name="offset">The position in the <paramref name="buffer"/> of the first byte to read.</param>
            <param name="littleEndian">Should the bytes be interpreted as little-endian? If false, big endian is used.</param>
            <returns>The resulting value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="offset"/> is invalid (accounting for
            the size of an <see cref="T:System.Int16"/>).</exception>
        </member>
        <member name="M:Storage.Data.Binary.GetDoubleBytes(System.Double,System.Boolean)">
            <summary>
            Converts a <see cref="T:System.Double"/> to a byte array.
            </summary>
            <param name="value">The <see cref="T:System.Double"/> value.</param>
            <param name="littleEndian">Should the bytes be ordered in little-endian? If false, big endian is used.</param>
            <returns>The eight bytes.</returns>
        </member>
        <member name="M:Storage.Data.Binary.ReadDouble(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Reads a <see cref="T:System.Double"/> from a byte array.
            </summary>
            <param name="buffer">The buffer containing the value.</param>
            <param name="offset">The position in the <paramref name="buffer"/> of the first byte to read.</param>
            <param name="littleEndian">Should the bytes be interpreted as little-endian? If false, big endian is used.</param>
            <returns>The resulting value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="offset"/> is invalid (accounting for
            the size of an <see cref="T:System.Int16"/>).</exception>
        </member>
        <member name="T:Storage.Data.BinaryReaderEx">
            <summary>
            Similar to <see cref="T:System.IO.BinaryReader"/>, but uses a specific endianness.
            </summary>
        </member>
        <member name="P:Storage.Data.BinaryReaderEx.BaseStream">
            <summary>
            The base <see cref="T:System.IO.Stream"/> from which this <see cref="T:Storage.Data.BinaryReaderEx"/>
            reads data.
            </summary>
        </member>
        <member name="P:Storage.Data.BinaryReaderEx.WillLeaveStreamOpen">
            <summary>
            Will the <see cref="P:Storage.Data.BinaryReaderEx.BaseStream"/> remain open after this <see cref="T:Storage.Data.BinaryReaderEx"/>
            is disposed?
            </summary>
        </member>
        <member name="P:Storage.Data.BinaryReaderEx.ReadsLittleEndian">
            <summary>
            Is data stored in little-endian format on the <see cref="P:Storage.Data.BinaryReaderEx.BaseStream"/>?
            </summary>
        </member>
        <member name="M:Storage.Data.BinaryReaderEx.#ctor(System.IO.Stream,System.Boolean,System.Boolean)">
            <summary>
            Constructs a <see cref="T:Storage.Data.BinaryReaderEx"/> that uses UTF-8 encoding.
            </summary>
            <param name="baseStream">The base <see cref="T:System.IO.Stream"/> from which data will be read.</param>
            <param name="leaveStreamOpen">Should the <paramref name="baseStream"/> remain open after
            this <see cref="T:Storage.Data.BinaryReaderEx"/> is disposed? If false, then <paramref name="baseStream"/>
            will be disposed when this <see cref="T:Storage.Data.BinaryReaderEx"/> is disposed.</param>
            <param name="littleEndian">Is the data stored in little-endian format?</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="baseStream"/> is null.</exception>
        </member>
        <member name="M:Storage.Data.BinaryReaderEx.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Boolean)">
            <summary>
            Constructs a <see cref="T:Storage.Data.BinaryReaderEx"/>.
            </summary>
            <param name="baseStream">The base <see cref="T:System.IO.Stream"/> from which data will be read.</param>
            <param name="encoding">The <see cref="T:System.Text.Encoding"/> to use when reading <see cref="T:System.String"/>s.</param>
            <param name="leaveStreamOpen">Should the <paramref name="baseStream"/> remain open after
            this <see cref="T:Storage.Data.BinaryReaderEx"/> is disposed? If false, then <paramref name="baseStream"/>
            will be disposed when this <see cref="T:Storage.Data.BinaryReaderEx"/> is disposed.</param>
            <param name="littleEndian">Is the data stored in little-endian format?</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="baseStream"/> or <paramref name="encoding"/> is null.</exception>
        </member>
        <member name="M:Storage.Data.BinaryReaderEx.ReadBoolean">
            <summary>
            Reads a single byte and determines whether it
            represents a true value or a false value.
            </summary>
            <returns>True if the byte is non-zero, otherwise false.</returns>
        </member>
        <member name="M:Storage.Data.BinaryReaderEx.ReadInt16">
            <summary>
            Reads an <see cref="T:System.Int16"/> from the <see cref="P:Storage.Data.BinaryReaderEx.BaseStream"/>.
            </summary>
            <returns>The <see cref="T:System.Int16"/> value.</returns>
        </member>
        <member name="M:Storage.Data.BinaryReaderEx.ReadUInt16">
            <summary>
            Reads an <see cref="T:System.UInt16"/> from the <see cref="P:Storage.Data.BinaryReaderEx.BaseStream"/>.
            </summary>
            <returns>The <see cref="T:System.UInt16"/> value.</returns>
        </member>
        <member name="M:Storage.Data.BinaryReaderEx.ReadInt32">
            <summary>
            Reads an <see cref="T:System.Int32"/> from the <see cref="P:Storage.Data.BinaryReaderEx.BaseStream"/>.
            </summary>
            <returns>The <see cref="T:System.Int32"/> value.</returns>
        </member>
        <member name="M:Storage.Data.BinaryReaderEx.ReadUInt32">
            <summary>
            Reads an <see cref="T:System.UInt32"/> from the <see cref="P:Storage.Data.BinaryReaderEx.BaseStream"/>.
            </summary>
            <returns>The <see cref="T:System.UInt32"/> value.</returns>
        </member>
        <member name="M:Storage.Data.BinaryReaderEx.ReadInt64">
            <summary>
            Reads an <see cref="T:System.Int64"/> from the <see cref="P:Storage.Data.BinaryReaderEx.BaseStream"/>.
            </summary>
            <returns>The <see cref="T:System.Int64"/> value.</returns>
        </member>
        <member name="M:Storage.Data.BinaryReaderEx.ReadUInt64">
            <summary>
            Reads an <see cref="T:System.UInt64"/> from the <see cref="P:Storage.Data.BinaryReaderEx.BaseStream"/>.
            </summary>
            <returns>The <see cref="T:System.UInt64"/> value.</returns>
        </member>
        <member name="M:Storage.Data.BinaryReaderEx.ReadShortString">
            <summary>
            Reads a <see cref="T:System.UInt16"/>-prefixed <see cref="T:System.String"/>.
            </summary>
            <returns>The <see cref="T:System.String"/> value.</returns>
            <remarks>
            This method will call <see cref="M:Storage.Data.BinaryReaderEx.ReadUInt16"/> to determine how
            many bytes to read for the <see cref="T:System.String"/>, and then will
            read that many bytes, and decode the <see cref="T:System.String"/> using
            the <see cref="T:System.Text.Encoding"/> that was specified in the constructor.
            </remarks>
        </member>
        <member name="M:Storage.Data.BinaryReaderEx.ReadSingle">
            <summary>
            Reads a <see cref="T:System.Single"/> from the <see cref="P:Storage.Data.BinaryReaderEx.BaseStream"/>.
            </summary>
            <returns>The <see cref="T:System.Single"/> value.</returns>
        </member>
        <member name="M:Storage.Data.BinaryReaderEx.ReadDouble">
            <summary>
            Reads a <see cref="T:System.Double"/> from the <see cref="P:Storage.Data.BinaryReaderEx.BaseStream"/>.
            </summary>
            <returns>The <see cref="T:System.Double"/> value.</returns>
        </member>
        <member name="M:Storage.Data.BinaryReaderEx.Dispose">
            <summary>
            Disposes this <see cref="T:Storage.Data.BinaryReaderEx"/>.
            </summary>
            <remarks>
            The <see cref="P:Storage.Data.BinaryReaderEx.BaseStream"/> will be disposed unless <see cref="P:Storage.Data.BinaryReaderEx.WillLeaveStreamOpen"/> is true.
            </remarks>
        </member>
        <member name="T:Storage.Data.BinaryWriterEx">
            <summary>
            Similar to <see cref="T:System.IO.BinaryWriter"/>, but uses a specific endianness.
            </summary>
        </member>
        <member name="P:Storage.Data.BinaryWriterEx.BaseStream">
            <summary>
            The base <see cref="T:System.IO.Stream"/> to which this <see cref="T:Storage.Data.BinaryWriterEx"/>
            writes data.
            </summary>
        </member>
        <member name="P:Storage.Data.BinaryWriterEx.WillLeaveStreamOpen">
            <summary>
            Will the <see cref="P:Storage.Data.BinaryWriterEx.BaseStream"/> remain open after this <see cref="T:Storage.Data.BinaryWriterEx"/>
            is disposed?
            </summary>
        </member>
        <member name="P:Storage.Data.BinaryWriterEx.WritesLittleEndian">
            <summary>
            Will data be written to the <see cref="P:Storage.Data.BinaryWriterEx.BaseStream"/> in little-endian format?
            </summary>
        </member>
        <member name="M:Storage.Data.BinaryWriterEx.#ctor(System.IO.Stream,System.Boolean,System.Boolean)">
            <summary>
            Constructs a <see cref="T:Storage.Data.BinaryWriterEx"/> that uses UTF-8 encoding.
            </summary>
            <param name="baseStream">The base <see cref="T:System.IO.Stream"/> to which data will be written.</param>
            <param name="leaveStreamOpen">Should the <paramref name="baseStream"/> remain open after
            this <see cref="T:Storage.Data.BinaryWriterEx"/> is disposed? If false, then <paramref name="baseStream"/>
            will be disposed when this <see cref="T:Storage.Data.BinaryWriterEx"/> is disposed.</param>
            <param name="littleEndian">Should data be written in little-endian format? If false, big-endian
            is used.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="baseStream"/> is null.</exception>
        </member>
        <member name="M:Storage.Data.BinaryWriterEx.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Boolean)">
            <summary>
            Constructs a <see cref="T:Storage.Data.BinaryWriterEx"/>.
            </summary>
            <param name="baseStream">The base <see cref="T:System.IO.Stream"/> to which data will be written.</param>
            <param name="encoding">The <see cref="T:System.Text.Encoding"/> to use when writing <see cref="T:System.String"/>s.</param>
            <param name="leaveStreamOpen">Should the <paramref name="baseStream"/> remain open after
            this <see cref="T:Storage.Data.BinaryWriterEx"/> is disposed? If false, then <paramref name="baseStream"/>
            will be disposed when this <see cref="T:Storage.Data.BinaryWriterEx"/> is disposed.</param>
            <param name="littleEndian">Should data be written in little-endian format? If false, big-endian
            is used.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="baseStream"/> or
            <paramref name="encoding"/> is null.</exception>
        </member>
        <member name="M:Storage.Data.BinaryWriterEx.WriteBoolean(System.Boolean)">
            <summary>
            Writes a <see cref="T:System.Boolean"/> to the <see cref="P:Storage.Data.BinaryWriterEx.BaseStream"/>.
            </summary>
            <param name="value">The value to write.</param>
            <remarks>
            If <paramref name="value"/> is false, a zero byte will be written.
            Otherwise the application should assume that any arbitrary non-zero
            byte will be written.
            </remarks>
        </member>
        <member name="M:Storage.Data.BinaryWriterEx.WriteInt16(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16"/> to the <see cref="P:Storage.Data.BinaryWriterEx.BaseStream"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:Storage.Data.BinaryWriterEx.WriteUInt16(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16"/> to the <see cref="P:Storage.Data.BinaryWriterEx.BaseStream"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:Storage.Data.BinaryWriterEx.WriteInt32(System.Int32)">
            <summary>
            Writes a <see cref="T:System.Int32"/> to the <see cref="P:Storage.Data.BinaryWriterEx.BaseStream"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:Storage.Data.BinaryWriterEx.WriteUInt32(System.UInt32)">
            <summary>
            Writes a <see cref="T:System.UInt32"/> to the <see cref="P:Storage.Data.BinaryWriterEx.BaseStream"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:Storage.Data.BinaryWriterEx.WriteInt64(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64"/> to the <see cref="P:Storage.Data.BinaryWriterEx.BaseStream"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:Storage.Data.BinaryWriterEx.WriteUInt64(System.UInt64)">
            <summary>
            Writes a <see cref="T:System.UInt64"/> to the <see cref="P:Storage.Data.BinaryWriterEx.BaseStream"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:Storage.Data.BinaryWriterEx.WriteShortString(System.String)">
            <summary>
            Writes a <see cref="T:System.UInt16"/>-prefixed <see cref="T:System.String"/>.
            </summary>
            <param name="value">The value to write.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="value"/>, when encoded
            using the constructor-specified <see cref="T:System.Text.Encoding"/>, requires more than
            <see cref="F:System.UInt16.MaxValue"/> bytes.</exception>
            <remarks>
            <para>
            Note that the <paramref name="value"/> cannot have more than <see cref="F:System.UInt16.MaxValue"/>
            bytes (when encoded using the constructor-specified <see cref="T:System.Text.Encoding"/>, see
            <see cref="M:System.Text.Encoding.GetByteCount(System.String)"/>).
            </para>
            <para>
            A <see cref="T:System.UInt16"/> header will be written before the <see cref="T:System.String"/>'s
            bytes to define how many bytes are used. This may be different from the
            <see cref="P:System.String.Length"/> of the <paramref name="value"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Storage.Data.BinaryWriterEx.WriteSingle(System.Single)">
            <summary>
            Writes a <see cref="T:System.Single"/> to the <see cref="P:Storage.Data.BinaryWriterEx.BaseStream"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:Storage.Data.BinaryWriterEx.WriteDouble(System.Double)">
            <summary>
            Writes a <see cref="T:System.Double"/> to the <see cref="P:Storage.Data.BinaryWriterEx.BaseStream"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:Storage.Data.BinaryWriterEx.Dispose">
            <summary>
            Disposes this <see cref="T:Storage.Data.BinaryWriterEx"/>.
            </summary>
            <remarks>
            The <see cref="P:Storage.Data.BinaryWriterEx.BaseStream"/> will be disposed unless <see cref="P:Storage.Data.BinaryWriterEx.WillLeaveStreamOpen"/> is true.
            </remarks>
        </member>
        <member name="T:Storage.Data.CorruptDataException">
            <summary>
            <see cref="T:System.IO.IOException"/> that indicates corrupt data.
            </summary>
        </member>
        <member name="M:Storage.Data.CorruptDataException.#ctor(System.String)">
            <summary>
            <see cref="T:Storage.Data.CorruptDataException"/> constructor.
            </summary>
            <param name="message">Descriptive message of the error.</param>
        </member>
        <member name="M:Storage.Data.CorruptDataException.#ctor(System.Exception,System.String)">
            <summary>
            <see cref="T:Storage.Data.CorruptDataException"/> constructor.
            </summary>
            <param name="innerException">The <see cref="T:System.Exception"/> that caused this
            <see cref="T:Storage.Data.CorruptDataException"/> to be thrown, if any.</param>
            <param name="message">Descriptive message of the error.</param>
        </member>
        <member name="T:Storage.Data.DataRegion">
            <summary>
            Defines a region of data.
            </summary>
        </member>
        <member name="P:Storage.Data.DataRegion.FirstIndex">
            <summary>
            The first index of the data region.
            </summary>
        </member>
        <member name="P:Storage.Data.DataRegion.LastIndex">
            <summary>
            The last index of the data region.
            </summary>
        </member>
        <member name="P:Storage.Data.DataRegion.Length">
            <summary>
            The length of the data.
            </summary>
        </member>
        <member name="M:Storage.Data.DataRegion.#ctor(System.Int64,System.Int64)">
            <summary>
            <see cref="T:Storage.Data.DataRegion"/> constructor.
            </summary>
            <param name="firstIndex">The first index of the data region.</param>
            <param name="lastIndex">The last index of the data region.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="firstIndex"/>
            or <paramref name="lastIndex"/> is less than zero, or if <paramref name="lastIndex"/>
            is less than <paramref name="firstIndex"/>.</exception>
        </member>
        <member name="M:Storage.Data.DataRegion.ContainsIndex(System.Int64)">
            <summary>
            Checks whether this <see cref="T:Storage.Data.DataRegion"/> contains a specific index of data.
            </summary>
            <param name="index">The index.</param>
            <returns>True if this <see cref="T:Storage.Data.DataRegion"/> contains the specified <paramref name="index"/>,
            otherwise false.</returns>
        </member>
        <member name="M:Storage.Data.DataRegion.Contains(Storage.Data.DataRegion)">
            <summary>
            Checks whether this <see cref="T:Storage.Data.DataRegion"/> completely contains another.
            </summary>
            <param name="otherRegion">The other <see cref="T:Storage.Data.DataRegion"/>.</param>
            <returns>True if the <paramref name="otherRegion"/> completely fits within
            this <see cref="T:Storage.Data.DataRegion"/>, otherwise false.</returns>
        </member>
        <member name="M:Storage.Data.DataRegion.Intersects(Storage.Data.DataRegion)">
            <summary>
            Checks whether this <see cref="T:Storage.Data.DataRegion"/> intersects another.
            </summary>
            <param name="otherRegion">The other <see cref="T:Storage.Data.DataRegion"/>.</param>
            <returns>True if this <see cref="T:Storage.Data.DataRegion"/> contains at least one
            index that is also contained by the <paramref name="otherRegion"/>,
            otherwise false.</returns>
        </member>
        <member name="M:Storage.Data.DataRegion.IsAdjacent(Storage.Data.DataRegion)">
            <summary>
            Checks whether this <see cref="T:Storage.Data.DataRegion"/> is adjacent to another.
            </summary>
            <param name="otherRegion">The other <see cref="T:Storage.Data.DataRegion"/>.</param>
            <returns>True if this <see cref="T:Storage.Data.DataRegion"/> is adjacent to <paramref name="otherRegion"/>,
            otherwise false.</returns>
            <remarks>
            Two <see cref="T:Storage.Data.DataRegion"/>s are considered adjacent only if there is
            no gap between them. Intersecting <see cref="T:Storage.Data.DataRegion"/>s are <em>not</em>
            considered adjacent.
            </remarks>
        </member>
        <member name="M:Storage.Data.DataRegion.CanCombineWith(Storage.Data.DataRegion)">
            <summary>
            Checks whether this <see cref="T:Storage.Data.DataRegion"/> can be combined with another.
            </summary>
            <param name="otherRegion">The other <see cref="T:Storage.Data.DataRegion"/>.</param>
            <returns>True if this <see cref="T:Storage.Data.DataRegion"/> can be combined with the <paramref name="otherRegion"/>,
            otherwise false.</returns>
            <remarks>
            Two <see cref="T:Storage.Data.DataRegion"/>s can be combined only if they are adjacent or
            intersecting. See <see cref="M:Storage.Data.DataRegion.Intersects(Storage.Data.DataRegion)"/> and
            <see cref="M:Storage.Data.DataRegion.IsAdjacent(Storage.Data.DataRegion)"/>.
            </remarks>
        </member>
        <member name="M:Storage.Data.DataRegion.CombineWith(Storage.Data.DataRegion)">
            <summary>
            Combines this <see cref="T:Storage.Data.DataRegion"/> with another one.
            </summary>
            <param name="otherRegion">The other <see cref="T:Storage.Data.DataRegion"/> that intersects
            with, or is adjacent to, this one.</param>
            <returns>The combined <see cref="T:Storage.Data.DataRegion"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="otherRegion"/>
            does not intersect with this one and is not adjacent to this one. 
            See <see cref="M:Storage.Data.DataRegion.CanCombineWith(Storage.Data.DataRegion)"/>.</exception>
        </member>
        <member name="M:Storage.Data.DataRegion.Equals(System.Object)">
            <summary>
            Checks whether this <see cref="T:Storage.Data.DataRegion"/> equals another object.
            </summary>
            <param name="obj">The other object.</param>
            <returns>True if the <paramref name="obj"/> is a <see cref="T:Storage.Data.DataRegion"/> that
            is equivalent to this one, otherwise false.</returns>
        </member>
        <member name="M:Storage.Data.DataRegion.GetHashCode">
            <summary>
            Gets the hash code of this <see cref="T:Storage.Data.DataRegion"/>.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:Storage.Data.DataRegion.ToString">
            <summary>
            Generates a <see cref="T:System.String"/> representation of this <see cref="T:Storage.Data.DataRegion"/>.
            </summary>
            <returns>A <see cref="T:System.String"/> that describes this <see cref="T:Storage.Data.DataRegion"/>.</returns>
        </member>
        <member name="T:Storage.Data.DataRegionSet">
            <summary>
            Set of <see cref="T:Storage.Data.DataRegion"/>s.
            </summary>
        </member>
        <member name="M:Storage.Data.DataRegionSet.#ctor">
            <summary>
            <see cref="T:Storage.Data.DataRegionSet"/> constructor.
            </summary>
        </member>
        <member name="M:Storage.Data.DataRegionSet.Add(Storage.Data.DataRegion)">
            <summary>
            Adds a <see cref="T:Storage.Data.DataRegion"/> to this <see cref="T:Storage.Data.DataRegionSet"/>.
            </summary>
            <param name="region">The <see cref="T:Storage.Data.DataRegion"/> to add.</param>
            <returns>The input <paramref name="region"/> combined with all intersecting
            <see cref="T:Storage.Data.DataRegion"/>s within this <see cref="T:Storage.Data.DataRegionSet"/> (if any).
            See <see cref="M:Storage.Data.DataRegion.Intersects(Storage.Data.DataRegion)"/> and 
            <see cref="M:Storage.Data.DataRegion.CombineWith(Storage.Data.DataRegion)"/>.</returns>
            <remarks>
            If the <paramref name="region"/> intersects with any of the <see cref="T:Storage.Data.DataRegion"/>s
            currently stored in this <see cref="T:Storage.Data.DataRegionSet"/>, then it will be combined with
            them.
            </remarks>
            <seealso cref="M:Storage.Data.DataRegion.Intersects(Storage.Data.DataRegion)"/>
            <seealso cref="M:Storage.Data.DataRegion.CombineWith(Storage.Data.DataRegion)"/>
            <seealso cref="M:Storage.Data.DataRegionSet.Remove(Storage.Data.DataRegion)"/>
            <exception cref="T:System.InvalidOperationException">Thrown if this method is called
            while enumerating via <see cref="M:Storage.Data.DataRegionSet.GetEnumerator"/> (on the same thread).</exception>
        </member>
        <member name="M:Storage.Data.DataRegionSet.Remove(Storage.Data.DataRegion)">
            <summary>
            Removes a <see cref="T:Storage.Data.DataRegion"/> from this <see cref="T:Storage.Data.DataRegionSet"/>.
            </summary>
            <param name="toRemove">The <see cref="T:Storage.Data.DataRegion"/> to remove.</param>
            <remarks>
            Any <see cref="T:Storage.Data.DataRegion"/> stored by this <see cref="T:Storage.Data.DataRegionSet"/>
            that intersects with <paramref name="toRemove"/> will be affected. If any
            stored <see cref="T:Storage.Data.DataRegion"/> is completely contained by <paramref name="toRemove"/>,
            then it will be removed entirely. If any stored <see cref="T:Storage.Data.DataRegion"/>
            is partially intersected, then it will be updated to remove whatever portion
            was specified by <paramref name="toRemove"/>. This may cause some stored
            <see cref="T:Storage.Data.DataRegion"/>s to be split into two pieces (left and right).
            </remarks>
            <seealso cref="M:Storage.Data.DataRegionSet.Add(Storage.Data.DataRegion)"/>
            <exception cref="T:System.InvalidOperationException">Thrown if this method is called
            while enumerating via <see cref="M:Storage.Data.DataRegionSet.GetEnumerator"/> (on the same thread).</exception>
        </member>
        <member name="M:Storage.Data.DataRegionSet.GetRegionsWithin(Storage.Data.DataRegion)">
            <summary>
            Gets all <see cref="T:Storage.Data.DataRegion"/>s that are stored in this <see cref="T:Storage.Data.DataRegionSet"/>
            but bounded by a specific <see cref="T:Storage.Data.DataRegion"/>.
            </summary>
            <param name="boundaryRegion">The boundary <see cref="T:Storage.Data.DataRegion"/>.</param>
            <returns>All stored <see cref="T:Storage.Data.DataRegion"/>s bounded by the <paramref name="boundaryRegion"/>.</returns>
            <remarks>
            If any stored <see cref="T:Storage.Data.DataRegion"/> spans both inside and outside of the <paramref name="boundaryRegion"/>,
            then only the portion of that <see cref="T:Storage.Data.DataRegion"/> that fits inside of the <paramref name="boundaryRegion"/>
            will be returned.
            </remarks>
            <seealso cref="M:Storage.Data.DataRegionSet.GetMissingRegions(Storage.Data.DataRegion)"/>
        </member>
        <member name="M:Storage.Data.DataRegionSet.GetMissingRegions(Storage.Data.DataRegion)">
            <summary>
            Gets all <see cref="T:Storage.Data.DataRegion"/>s that are <em>not</em> stored in
            this <see cref="T:Storage.Data.DataRegionSet"/> within a specific boundary <see cref="T:Storage.Data.DataRegion"/>.
            </summary>
            <param name="boundaryRegion">The boundary <see cref="T:Storage.Data.DataRegion"/>.</param>
            <returns>All <see cref="T:Storage.Data.DataRegion"/>s within the <paramref name="boundaryRegion"/>
            that are <em>not</em> stored in this <see cref="T:Storage.Data.DataRegionSet"/>.</returns>
            <seealso cref="M:Storage.Data.DataRegionSet.GetRegionsWithin(Storage.Data.DataRegion)"/>
        </member>
        <member name="M:Storage.Data.DataRegionSet.GetEnumerator">
            <summary>
            Enumerates through all <see cref="T:Storage.Data.DataRegion"/>s, in ascending order.
            </summary>
            <returns>All <see cref="T:Storage.Data.DataRegion"/>s, in ascending order.</returns>
        </member>
        <member name="M:Storage.Data.DataRegionSet.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an <see cref="T:System.Collections.IEnumerator"/> to enumerate through all <see cref="T:Storage.Data.DataRegion"/>s
            in ascending order.
            </summary>
            <returns>The <see cref="T:System.Collections.IEnumerator"/>.</returns>
        </member>
        <member name="M:Storage.Data.DataRegionSet.Equals(System.Object)">
            <summary>
            Checks whether this <see cref="T:Storage.Data.DataRegionSet"/> is equivalent to another object.
            </summary>
            <param name="obj">The other object.</param>
            <returns>True if the <paramref name="obj"/> is a <see cref="T:Storage.Data.DataRegionSet"/> that is
            equivalent to this one, otherwise false.</returns>
        </member>
        <member name="M:Storage.Data.DataRegionSet.GetHashCode">
            <summary>
            Gets the hash code of this <see cref="T:Storage.Data.DataRegionSet"/>.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="T:Storage.Data.IStorageDictionary`2">
            <summary>
            Interface for a collection of key-value pairs that are stored on non-volatile storage.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="P:Storage.Data.IStorageDictionary`2.IsReadOnly">
            <summary>
            Is this <see cref="T:Storage.Data.IStorageDictionary`2"/> read-only?
            </summary>
        </member>
        <member name="P:Storage.Data.IStorageDictionary`2.Count">
            <summary>
            The number of key-value pairs that are stored.
            </summary>
        </member>
        <member name="M:Storage.Data.IStorageDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value that is associated to a key.
            </summary>
            <param name="key">The key.</param>
            <param name="valueOrDefault">Assigned to the value that is associated to
            the <paramref name="key"/>, or the default <typeparamref name="TValue"/>
            if it does not exist.</param>
            <returns>True if the key-value pair was found, otherwise false.</returns>
        </member>
        <member name="M:Storage.Data.IStorageDictionary`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add a new key-value pair.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
            <returns>True if the new key-value pair was added, false if it
            could not be added only due to a storage limitation.</returns>
            <remarks>
            This method will attempt to add a new key-value pair to the <see cref="T:Storage.Data.IStorageDictionary`2"/>.
            If the specified <paramref name="key"/> is already associated to a key-value pair stored in this
            <see cref="T:Storage.Data.IStorageDictionary`2"/>, then an <see cref="T:System.ArgumentException"/> will be thrown.
            If the implementation is unable to add a new key-value pair due to storage limitations, then false
            will be returned and nothing will change. All other failures will be reported via the implementation
            throwing an <see cref="T:System.Exception"/>.
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown if there is already a key-value pair with the specified
            <paramref name="key"/>.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.Data.IStorageDictionary`2.IsReadOnly"/> is true.</exception>
        </member>
        <member name="M:Storage.Data.IStorageDictionary`2.TryAddOrUpdate(`0,`1,System.Boolean@)">
            <summary>
            Attempts to add a new key-value pair, or update an existing one.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <param name="alreadyExists">Assigned to true if the key-value pair already existed, otherwise false.</param>
            <returns>True if a new key-value pair was added or an existing one's value was updated. False indicates
            that there was no existing key-value pair with the <paramref name="key"/>, and a new key-value pair could
            not be inserted only due to storage limitations.</returns>
            <remarks>
            This method will check whether there is an existing key-value pair with the specified <paramref name="key"/>,
            and if so, update the value of that key-value pair to the specified new <paramref name="value"/>. If an existing
            key-value pair does not exist, then a new one will be added. If the implementation cannot add a new key-value pair due
            to storage limitations, then false will be returned and nothing will change. All other failures will be reported by
            the implementation throwing an <see cref="T:System.Exception"/>.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.Data.IStorageDictionary`2.IsReadOnly"/> is true.</exception>
        </member>
        <member name="M:Storage.Data.IStorageDictionary`2.UpdateValue(`0,`1)">
            <summary>
            Updates the value to an existing key-value pair.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The new value to assign.</param>
            <remarks>
            This method will only update the value of an existing key-value pair.
            </remarks>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if there is no key-value pair with the specified <paramref name="key"/>.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.Data.IStorageDictionary`2.IsReadOnly"/> is true.</exception>
        </member>
        <member name="M:Storage.Data.IStorageDictionary`2.Remove(`0,`1@)">
            <summary>
            Removes a key-value pair.
            </summary>
            <param name="key">The key.</param>
            <param name="removedValueOrDefault">Assigned to the value that was removed, or default if nothing was removed.</param>
            <returns>True if the key-value pair was removed, false if it did not exist.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.Data.IStorageDictionary`2.IsReadOnly"/> is true.</exception>
        </member>
        <member name="M:Storage.Data.IStorageDictionary`2.ContainsKey(`0)">
            <summary>
            Checks whether there is a key-value pair with a specific key.
            </summary>
            <param name="key">The key to find.</param>
            <returns>True if there is a key-value pair with the specified <paramref name="key"/>, otherwise false.</returns>
        </member>
        <member name="T:Storage.Data.Serializers.Int32Serializer">
            <summary>
            <see cref="T:Storage.Data.Serializers.ISerializer`1"/> for 64-bit integers.
            </summary>
        </member>
        <member name="P:Storage.Data.Serializers.Int32Serializer.StoreAsLittleEndian">
            <summary>
            Will values be represented and interpreted as little-endian? If false,
            big-endian is assumed.
            </summary>
        </member>
        <member name="P:Storage.Data.Serializers.Int32Serializer.DataSize">
            <summary>
            The size, in bytes, of the serialized data.
            </summary>
        </member>
        <member name="M:Storage.Data.Serializers.Int32Serializer.#ctor(System.Boolean)">
            <summary>
            <see cref="T:Storage.Data.Serializers.Int32Serializer"/> constructor.
            </summary>
            <param name="useLittleEndian">Will values be represented and interpreted as little-endian? If false,
            big-endian is assumed.</param>
        </member>
        <member name="M:Storage.Data.Serializers.Int32Serializer.Deserialize(System.Byte[])">
            <summary>
            Deserializes a buffer to an <see cref="T:System.Int32"/>.
            </summary>
            <param name="buffer">The buffer.</param>
            <returns>The resulting <see cref="T:System.Int32"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="buffer"/> is not <see cref="P:Storage.Data.Serializers.Int32Serializer.DataSize"/>
            bytes long.</exception>
        </member>
        <member name="M:Storage.Data.Serializers.Int32Serializer.Serialize(System.Int32,System.Byte[])">
            <summary>
            Serializes an <see cref="T:System.Int32"/> to a byte array.
            </summary>
            <param name="value">The value to serialize.</param>
            <param name="buffer">The buffer into which to write the serialized data.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="buffer"/> is not <see cref="P:Storage.Data.Serializers.Int32Serializer.DataSize"/>
            bytes long.</exception>
        </member>
        <member name="T:Storage.Data.Serializers.Int64Serializer">
            <summary>
            <see cref="T:Storage.Data.Serializers.ISerializer`1"/> for 64-bit integers.
            </summary>
        </member>
        <member name="P:Storage.Data.Serializers.Int64Serializer.StoreAsLittleEndian">
            <summary>
            Will values be represented and interpreted as little-endian? If false,
            big-endian is assumed.
            </summary>
        </member>
        <member name="P:Storage.Data.Serializers.Int64Serializer.DataSize">
            <summary>
            The size, in bytes, of the serialized data.
            </summary>
        </member>
        <member name="M:Storage.Data.Serializers.Int64Serializer.#ctor(System.Boolean)">
            <summary>
            <see cref="T:Storage.Data.Serializers.Int64Serializer"/> constructor.
            </summary>
            <param name="useLittleEndian">Will values be represented and interpreted as little-endian? If false,
            big-endian is assumed.</param>
        </member>
        <member name="M:Storage.Data.Serializers.Int64Serializer.Deserialize(System.Byte[])">
            <summary>
            Deserializes a buffer to an <see cref="T:System.Int64"/>.
            </summary>
            <param name="buffer">The buffer.</param>
            <returns>The resulting <see cref="T:System.Int64"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="buffer"/> is not <see cref="P:Storage.Data.Serializers.Int64Serializer.DataSize"/>
            bytes long.</exception>
        </member>
        <member name="M:Storage.Data.Serializers.Int64Serializer.Serialize(System.Int64,System.Byte[])">
            <summary>
            Serializes an <see cref="T:System.Int64"/> to a byte array.
            </summary>
            <param name="value">The value to serialize.</param>
            <param name="buffer">The buffer into which to write the serialized data.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="buffer"/> is not <see cref="P:Storage.Data.Serializers.Int64Serializer.DataSize"/>
            bytes long.</exception>
        </member>
        <member name="T:Storage.Data.Serializers.ISerializer`1">
            <summary>
            Interface that can serialize and deserialize types stored in fixed-length buffers.
            </summary>
        </member>
        <member name="P:Storage.Data.Serializers.ISerializer`1.DataSize">
            <summary>
            The size, in bytes, of a serialized <typeparamref name="T"/>.
            </summary>
            <remarks>
            This property must remain constant. The <see cref="M:Storage.Data.Serializers.ISerializer`1.Serialize(`0,System.Byte[])"/>
            and <see cref="M:Storage.Data.Serializers.ISerializer`1.Deserialize(System.Byte[])"/> methods will be given buffers of this size.
            </remarks>
        </member>
        <member name="M:Storage.Data.Serializers.ISerializer`1.Serialize(`0,System.Byte[])">
            <summary>
            Writes the state of a <typeparamref name="T"/> to a buffer.
            </summary>
            <param name="value">The <typeparamref name="T"/> to serialize.</param>
            <param name="buffer">The buffer into which to write the serialized
            data. Must be exactly <see cref="P:Storage.Data.Serializers.ISerializer`1.DataSize"/> bytes long.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="buffer"/>
            is not exactly <see cref="P:Storage.Data.Serializers.ISerializer`1.DataSize"/> bytes long.</exception>
        </member>
        <member name="M:Storage.Data.Serializers.ISerializer`1.Deserialize(System.Byte[])">
            <summary>
            Reads the state of a <typeparamref name="T"/> from a buffer.
            </summary>
            <param name="buffer">The buffer from which to read the serialized
            data. Must be exactly <see cref="P:Storage.Data.Serializers.ISerializer`1.DataSize"/> bytes long.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="buffer"/>
            is not exactly <see cref="P:Storage.Data.Serializers.ISerializer`1.DataSize"/> bytes long.</exception>
            <exception cref="T:Storage.Data.CorruptDataException">Thrown if the data stored in
            the <paramref name="buffer"/> is corrupt. Note that some implementations
            may throw other <see cref="T:System.Exception"/> types to indicate data corruption
            too, but <see cref="T:Storage.Data.CorruptDataException"/> is the preferred type.</exception>
            <returns>The resulting <typeparamref name="T"/>.</returns>
        </member>
        <member name="T:Storage.Data.StorageDictionary`2">
            <summary>
            <see cref="T:Storage.Data.IStorageDictionary`2"/> implementation.
            </summary>
            <typeparam name="TKey">The key type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
        </member>
        <member name="P:Storage.Data.StorageDictionary`2.PageIndex">
            <summary>
            The index of the metadata page on the <see cref="T:Storage.IPageStorage"/>.
            </summary>
            <remarks>
            The application is expected to keep track of this index so that it may
            load the <see cref="T:Storage.Data.StorageDictionary`2"/> in the future.
            </remarks>
        </member>
        <member name="P:Storage.Data.StorageDictionary`2.IsReadOnly">
            <summary>
            Is this <see cref="T:Storage.Data.StorageDictionary`2"/> read-only?
            </summary>
        </member>
        <member name="P:Storage.Data.StorageDictionary`2.Count">
            <summary>
            The number of key-value pairs.
            </summary>
        </member>
        <member name="F:Storage.Data.StorageDictionary`2.MinKeyValuePairCountPerNode">
            <summary>
            The minimum number of key-value pairs that can be stored in a <see cref="T:Storage.Data.BTreeNode`2"/>.
            </summary>
            <remarks>
            Note that this is the <em>very minimum</em> capacity. Practical applications should use a much higher
            capacity, as using this amount is likely to be woefully inefficient.
            </remarks>
        </member>
        <member name="M:Storage.Data.StorageDictionary`2.GetRequiredPageSize(System.Int64,System.Int64,System.Int64)">
            <summary>
            Gets the page size that is required to support a <see cref="T:Storage.Data.StorageDictionary`2"/>.
            </summary>
            <param name="keySize">The <see cref="P:Storage.Data.Serializers.ISerializer`1.DataSize"/> of the key, measured in bytes.</param>
            <param name="valueSize">The <see cref="P:Storage.Data.Serializers.ISerializer`1.DataSize"/> of the value, measured in bytes.</param>
            <param name="keyValuePairCapacityPerNode">The maximum number of key-value pairs to internally store
            in a <see cref="T:Storage.Data.BTreeNode`2"/>. Must be an odd number, and must not be less than
            <see cref="F:Storage.Data.StorageDictionary`2.MinKeyValuePairCountPerNode"/>.</param>
            <returns>The required page size, measured in bytes.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="keySize"/> is less than one,
            <paramref name="valueSize"/> is less than zero, or <paramref name="keyValuePairCapacityPerNode"/>
            is less than <see cref="F:Storage.Data.StorageDictionary`2.MinKeyValuePairCountPerNode"/>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="keyValuePairCapacityPerNode"/>
            is an even number.</exception>
        </member>
        <member name="M:Storage.Data.StorageDictionary`2.GetVeryMinRequiredPageSize(System.Int64,System.Int64)">
            <summary>
            Gets the very minimum required page size.
            </summary>
            <param name="keySize">The <see cref="P:Storage.Data.Serializers.ISerializer`1.DataSize"/> of the key, measured in bytes.</param>
            <param name="valueSize">The <see cref="P:Storage.Data.Serializers.ISerializer`1.DataSize"/> of the value, measured in bytes.</param>
            <returns>The minimum page size, measured in bytes.</returns>
            <remarks>
            Note that this is based on <see cref="F:Storage.Data.StorageDictionary`2.MinKeyValuePairCountPerNode"/>, which is likely to be inefficient
            for most applications.
            </remarks>
            <seealso cref="M:Storage.Data.StorageDictionary`2.GetRequiredPageSize(System.Int64,System.Int64,System.Int64)"/>
            <seealso cref="F:Storage.Data.StorageDictionary`2.MinKeyValuePairCountPerNode"/>
        </member>
        <member name="M:Storage.Data.StorageDictionary`2.TryCreate(Storage.IPageStorage,Storage.Data.Serializers.ISerializer{`0},Storage.Data.Serializers.ISerializer{`1},System.Int64@)">
            <summary>
            Attempts to create an empty <see cref="T:Storage.Data.StorageDictionary`2"/> using an <see cref="T:Storage.IPageStorage"/>.
            </summary>
            <param name="pageStorage">The <see cref="T:Storage.IPageStorage"/> on which the <see cref="T:Storage.Data.StorageDictionary`2"/>
            will store its data.</param>
            <param name="keySerializer"><see cref="T:Storage.Data.Serializers.ISerializer`1"/> that serializes and deserializes the keys.</param>
            <param name="valueSerializer"><see cref="T:Storage.Data.Serializers.ISerializer`1"/> that serializes and deserializes the values.</param>
            <param name="pageIndex">Assigned to the index of the metadata page that the application must remember so that it
            may load the <see cref="T:Storage.Data.StorageDictionary`2"/> in the future. See <see cref="P:Storage.Data.StorageDictionary`2.PageIndex"/>.</param>
            <returns>True if creation was successful, false if allocation failed.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="pageStorage"/>, <paramref name="keySerializer"/>,
            or <paramref name="valueSerializer"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if <paramref name="pageStorage"/> is read-only.</exception>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="pageStorage"/>'s <see cref="P:Storage.IPageStorage.PageSize"/>
            is less than the very minimum required size (see <see cref="M:Storage.Data.StorageDictionary`2.GetVeryMinRequiredPageSize(System.Int64,System.Int64)"/>).</exception>
            <remarks>
            <para>
            This method will only initialize the data stored on the <paramref name="pageStorage"/>. To obtain the
            <see cref="T:Storage.Data.StorageDictionary`2"/> instance, use the <see cref="M:Storage.Data.StorageDictionary`2.Load(Storage.IPageStorage,Storage.Data.Serializers.ISerializer{`0},Storage.Data.Serializers.ISerializer{`1},System.Int64,System.Boolean,System.Int32,System.Int64)"/>
            method (and remember to call <see cref="M:Storage.Data.StorageDictionary`2.Dispose"/> when finished
            using it).
            </para>
            <para>
            Note that this method will inflate the <paramref name="pageStorage"/> if it is at full capacity and not fixed-capacity.
            If inflation is required but the capacity is fixed, or if inflation fails, false will be returned.
            </para>
            </remarks>
            <seealso cref="M:Storage.Data.StorageDictionary`2.Load(Storage.IPageStorage,Storage.Data.Serializers.ISerializer{`0},Storage.Data.Serializers.ISerializer{`1},System.Int64,System.Boolean,System.Int32,System.Int64)"/>
        </member>
        <member name="M:Storage.Data.StorageDictionary`2.Load(Storage.IPageStorage,Storage.Data.Serializers.ISerializer{`0},Storage.Data.Serializers.ISerializer{`1},System.Int64,System.Boolean,System.Int32,System.Int64)">
            <summary>
            Loads a <see cref="T:Storage.Data.StorageDictionary`2"/> from an <see cref="T:Storage.IPageStorage"/>.
            </summary>
            <param name="pageStorage">The <see cref="T:Storage.IPageStorage"/> from which to load. This
            <see cref="T:Storage.Data.StorageDictionary`2"/> will <em>not</em> dispose it (because it
            is possible that other APIs may also be using the <see cref="T:Storage.IPageStorage"/>).</param>
            <param name="keySerializer"><see cref="T:Storage.Data.Serializers.ISerializer`1"/> that serializes and deserializes the keys.</param>
            <param name="valueSerializer"><see cref="T:Storage.Data.Serializers.ISerializer`1"/> that serializes and deserializes the values.</param>
            <param name="pageIndex">The index of the page on the <paramref name="pageStorage"/> that contains the
            metadata for the <see cref="T:Storage.Data.StorageDictionary`2"/>. This was determined during creation via
            the <see cref="M:Storage.Data.StorageDictionary`2.TryCreate(Storage.IPageStorage,Storage.Data.Serializers.ISerializer{`0},Storage.Data.Serializers.ISerializer{`1},System.Int64@)"/>
            method.</param>
            <param name="isReadOnly">Should the <see cref="T:Storage.Data.StorageDictionary`2"/> be loaded as read-only? Must be true
            if the <paramref name="pageStorage"/> is read-only.</param>
            <param name="cachePageCount">The maximum number of pages to store in cache. May be zero, in which case caching
            will not be used. If <paramref name="pageStorage"/> already provides caching, then this should be zero.</param>
            <param name="maxMoveCount">The maximum number of key-value pairs to move at once during certain operations.
            Larger values may improve operation speed, but cost more memory. The memory cost is equivalent to the
            <see cref="P:Storage.Data.Serializers.ISerializer`1.DataSize"/> of the <paramref name="keySerializer"/> and the <paramref name="valueSerializer"/>,
            plus 8-bytes of header data, all multiplied by this argument.</param>
            <returns>The loaded <see cref="T:Storage.Data.StorageDictionary`2"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if any argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="cachePageCount"/> is less than zero or
            <paramref name="maxMoveCount"/> is less than one.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="pageStorage"/> is read-only but
            <paramref name="isReadOnly"/> is false, or if the page on <paramref name="pageStorage"/> at
            <paramref name="pageIndex"/> is not allocated or does not exist, or if the size of the pages on
            the <paramref name="pageStorage"/> is less than the very minimum valid page size.</exception>
        </member>
        <member name="M:Storage.Data.StorageDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated to a specific key, if it exists.
            </summary>
            <param name="key">The key.</param>
            <param name="valueOrDefault">Assigned to the associated value, or the default
            <typeparamref name="TValue"/> value if the key was not found.</param>
            <returns>True if the key was found, otherwise false.</returns>
        </member>
        <member name="M:Storage.Data.StorageDictionary`2.TryAdd(`0,`1)">
            <summary>
            Adds a new key-value pair.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns>True if addition was successful, false if it failed only due to capacity limitations
            on the base <see cref="T:Storage.IPageStorage"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.Data.StorageDictionary`2.IsReadOnly"/> is true or if this
            method is called from a thread that is currently enumerating via <see cref="M:Storage.Data.StorageDictionary`2.GetEnumerator"/>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="key"/> already exists in
            this <see cref="T:Storage.Data.StorageDictionary`2"/>.</exception>
            <remarks>
            This method will only add a new key-value pair, it will not update an existing one.
            The base <see cref="T:Storage.IPageStorage"/> may be inflated by this method if necessary (unless
            it is fixed-capacity). If inflation is required, but not possible or fails, then the
            new key-value pair will not be added and false will be returned (this is considered
            a graceful failure). If there is already a key-value pair with the specified
            <paramref name="key"/>, then an <see cref="T:System.ArgumentException"/> will be thrown and
            nothing will change. Any other failure will be reported by an <see cref="T:System.Exception"/>
            (of any type) being thrown, and may indicate data corruption.
            </remarks>
        </member>
        <member name="M:Storage.Data.StorageDictionary`2.TryAddOrUpdate(`0,`1,System.Boolean@)">
            <summary>
            Adds a new key-value pair, or updates an existing one.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <param name="alreadyExists">Assigned to true if an existing key-value pair was
            updated, otherwise false. This should be considered undefined if false is returned.</param>
            <returns>True if the new key-value pair was added, or an existing one was updated.
            False only indicates failure to add a new key-value pair due to capacity limitations
            on the base <see cref="T:Storage.IPageStorage"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.Data.StorageDictionary`2.IsReadOnly"/> is true or if this
            method is called from a thread that is currently enumerating via <see cref="M:Storage.Data.StorageDictionary`2.GetEnumerator"/>.</exception>
            <remarks>
            This method will check whether a key-value pair already exists with the specified 
            <paramref name="key"/>. If it does, then the value will be updated. Otherwise, a new key-value
            pair will be added. Addition of a new key-value pair may fail (as documented in the
            <see cref="M:Storage.Data.StorageDictionary`2.TryAdd(`0,`1)"/> method's remarks) if inflation of the base
            <see cref="T:Storage.IPageStorage"/> fails. In this case, false will be returned and
            no key-value pairs will be changed (this is considered a graceful failure).
            </remarks>
        </member>
        <member name="M:Storage.Data.StorageDictionary`2.UpdateValue(`0,`1)">
            <summary>
            Updates the value of an existing key-value pair.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value to assign.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.Data.StorageDictionary`2.IsReadOnly"/> is true or if this
            method is called from a thread that is currently enumerating via <see cref="M:Storage.Data.StorageDictionary`2.GetEnumerator"/>.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if there is no existing key-value pair with the
            specified <paramref name="key"/>.</exception>
        </member>
        <member name="M:Storage.Data.StorageDictionary`2.ContainsKey(`0)">
            <summary>
            Checks whether this <see cref="T:Storage.Data.StorageDictionary`2"/> contains a key-value pair
            with a specific key.
            </summary>
            <param name="key">The key to find.</param>
            <returns>True if this <see cref="T:Storage.Data.StorageDictionary`2"/> contains the specified
            <paramref name="key"/>, otherwise false.</returns>
        </member>
        <member name="M:Storage.Data.StorageDictionary`2.Remove(`0,`1@)">
            <summary>
            Removes a key-value pair.
            </summary>
            <param name="key">The key of the key-value pair to remove.</param>
            <param name="removedValueOrDefault">Assigned to the value of the removed key-value pair,
            or default <typeparamref name="TValue"/> if it did not exist.</param>
            <returns>True if the key-value pair was removed, false if it did not exist.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.Data.StorageDictionary`2.IsReadOnly"/> is true or if this
            method is called from a thread that is currently enumerating via <see cref="M:Storage.Data.StorageDictionary`2.GetEnumerator"/>.</exception>
        </member>
        <member name="M:Storage.Data.StorageDictionary`2.GetEnumerator">
            <summary>
            Enumerates through all key-value pairs, in ascending key order.
            </summary>
            <returns>All <see cref="T:System.Collections.Generic.KeyValuePair`2"/>s stored in this
            <see cref="T:Storage.Data.StorageDictionary`2"/>, in ascending key order.</returns>
        </member>
        <member name="M:Storage.Data.StorageDictionary`2.GetAuxDataSize(System.Int64)">
            <summary>
            Gets the size of auxiliary data that can be stored in the metadata page of a
            <see cref="T:Storage.Data.StorageDictionary`2"/>.
            </summary>
            <param name="pageSize">The size, in bytes, of each page on the
            <see cref="T:Storage.IPageStorage"/>.</param>
            <returns>The size, in bytes, of the auxiliary data.</returns>
            <remarks>
            For more information on auxiliary data, see <see cref="P:Storage.Data.StorageDictionary`2.AuxDataSize"/>.
            </remarks>
        </member>
        <member name="P:Storage.Data.StorageDictionary`2.AuxDataSize">
            <summary>
            The size, in auxiliary data, that can be stored in this <see cref="T:Storage.Data.StorageDictionary`2"/>'s
            "metadata" page.
            </summary>
            <remarks>
            <para>
            Each <see cref="T:Storage.Data.StorageDictionary`2"/> requires an entire page to be allocated on the
            <see cref="T:Storage.IPageStorage"/> to store metadata. The required metadata size is rather small, but each
            page is expected to be considerably larger. To avoid wasting that extra space, applications can
            store auxiliary data in it. The size of the auxiliary data is determined by this property.
            Applications should assume that it could be as low as zero, hence it is considered
            "auxiliary." Once a <see cref="T:Storage.Data.StorageDictionary`2"/> has been created
            in the <see cref="T:Storage.IPageStorage"/>, its auxiliary data size remains constant.
            </para>
            <para>
            Note that auxiliary data is considered undefined until it is written by the application.
            </para>
            </remarks>
            <seealso cref="M:Storage.Data.StorageDictionary`2.ReadAuxData(System.Int64,System.Byte[],System.Int64,System.Int64)"/>
            <seealso cref="M:Storage.Data.StorageDictionary`2.WriteAuxData(System.Int64,System.Byte[],System.Int64,System.Int64)"/>
        </member>
        <member name="M:Storage.Data.StorageDictionary`2.ReadAuxData(System.Int64,System.Byte[],System.Int64,System.Int64)">
            <summary>
            Reads from the application-defined auxiliary data that is stored in this <see cref="T:Storage.Data.StorageDictionary`2"/>'s
            metadata page.
            </summary>
            <param name="srcOffset">The source offset.</param>
            <param name="buffer">The destination buffer.</param>
            <param name="dstOffset">The destination offset within the <paramref name="buffer"/>.</param>
            <param name="length">The number of bytes to read.</param>
            <remarks>
            See <see cref="P:Storage.Data.StorageDictionary`2.AuxDataSize"/> for more information on auxiliary data.
            </remarks>
            <seealso cref="M:Storage.Data.StorageDictionary`2.WriteAuxData(System.Int64,System.Byte[],System.Int64,System.Int64)"/>
            <seealso cref="P:Storage.Data.StorageDictionary`2.AuxDataSize"/>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if any arguments are invalid.</exception>
        </member>
        <member name="M:Storage.Data.StorageDictionary`2.WriteAuxData(System.Int64,System.Byte[],System.Int64,System.Int64)">
            <summary>
            Writes to the application-defined auxiliary data that is stored in this <see cref="T:Storage.Data.StorageDictionary`2"/>'s
            metadata page.
            </summary>
            <param name="dstOffset">The destination offset.</param>
            <param name="buffer">The source buffer.</param>
            <param name="srcOffset">The source offset within the <paramref name="buffer"/>.</param>
            <param name="length">The number of bytes to write.</param>
            <remarks>
            See <see cref="P:Storage.Data.StorageDictionary`2.AuxDataSize"/> for more information on auxiliary data.
            </remarks>
            <seealso cref="M:Storage.Data.StorageDictionary`2.ReadAuxData(System.Int64,System.Byte[],System.Int64,System.Int64)"/>
            <seealso cref="P:Storage.Data.StorageDictionary`2.AuxDataSize"/>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if any arguments are invalid.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.Data.StorageDictionary`2.IsReadOnly"/> is true.</exception>
        </member>
        <member name="P:Storage.Data.StorageDictionary`2.IsDisposed">
            <summary>
            Has this <see cref="T:Storage.Data.StorageDictionary`2"/> been disposed?
            </summary>
        </member>
        <member name="M:Storage.Data.StorageDictionary`2.Dispose">
            <summary>
            Disposes this <see cref="T:Storage.Data.StorageDictionary`2"/>.
            </summary>
            <remarks>
            Note that this will <em>not</em> dispose the base <see cref="T:Storage.IPageStorage"/>, since
            it is assumed that multiple APIs may be using it.
            </remarks>
        </member>
        <member name="T:Storage.IBinarySearchable`2">
            <summary>
            Interface for a set of <see cref="T:System.Collections.Generic.KeyValuePair`2"/>s with unique keys,
            stored in ascending key order.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="M:Storage.IBinarySearchable`2.GetKeyAt(System.Int64)">
            <summary>
            Gets a <typeparamref name="TKey"/> key that is stored at a particular index.
            </summary>
            <param name="index">The index.</param>
            <returns>The <typeparamref name="TKey"/> key that is stored at the specified 
            <paramref name="index"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="index"/>
            is less than zero or greater than or equal to <see cref="P:Storage.IBinarySearchable`2.Count"/>.</exception>
            <remarks>
            Keys are stored in ascending order based on their index.
            </remarks>
        </member>
        <member name="M:Storage.IBinarySearchable`2.GetValueAt(System.Int64)">
            <summary>
            Gets a <typeparamref name="TValue"/> value that is stored at a particular index.
            </summary>
            <param name="index">The index.</param>
            <returns>The <typeparamref name="TValue"/> value that is stored at the specified
            <paramref name="index"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="index"/>
            is less than zero or greater than or equal to <see cref="P:Storage.IBinarySearchable`2.Count"/>.</exception>
            <remarks>
            Values are stored such that their indices match the indices of their keys.
            Calling <see cref="M:Storage.IBinarySearchable`2.GetKeyAt(System.Int64)"/> will get the key that is associated to
            the value at <paramref name="index"/>.
            </remarks>
        </member>
        <member name="P:Storage.IBinarySearchable`2.Count">
            <summary>
            The number of <see cref="T:System.Collections.Generic.KeyValuePair`2"/>s that are stored.
            </summary>
        </member>
        <member name="T:Storage.IPageStorage">
            <summary>
            Interface that can store fixed-length blocks of memory, called pages.
            </summary>
            <remarks>
            <para>An <see cref="T:Storage.IPageStorage"/> can be considered similar to an array of pages. Each
            page contains a fixed-length payload, defined by <see cref="P:Storage.IPageStorage.PageSize"/>. Some pages
            can be 'allocated' and some can be 'unallocated.' When an application has an 'allocated'
            page, it keeps track of the index of that page. The application can then write payload
            to, or read payload from, that page. Generally, this interface is used to store pages
            in non-volatile storage, such as a file.</para>
            <para>
            In this documentation, the terms 'allocated' and 'unallocated' apply to the pages as 
            presented to the application by this interface. This distinction is important because 
            internally, even pages which are referred to as 'unallocated' are indeed allocated, 
            but they are only allocated to the interface's implementation. Think of it this way:
            Unallocated pages are actually 'reserved' for allocation. This means that the internal
            implementation must obviously have allocated space for those unallocated (reserved) 
            pages.
            </para>
            <para>
            The total number of pages that may be allocated by the application is referred to as the
            <see cref="P:Storage.IPageStorage.PageCapacity"/>. This is actually the number of pages that were internally allocated
            by the implementation. This includes 'allocated' as well as 'unallocated' pages, as presented 
            to the application. The <see cref="P:Storage.IPageStorage.PageCapacity"/> can only be changed via the
            <see cref="M:Storage.IPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/> or 
            <see cref="M:Storage.IPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/> methods.
            </para>
            <para>
            Note that some implementations may internally allocate pages as they need. When this happens, the interface
            will make no distinction between pages that were allocated for the internal needs of the implementation and
            pages that were allocated by the application. This means, for example, that <see cref="P:Storage.IPageStorage.AllocatedPageCount"/>
            will account for the number of pages that were allocated for the internal implementation needs as well as the
            pages that were allocated by the application. The same is true for the <see cref="M:Storage.IPageStorage.IsPageAllocated(System.Int64)"/>
            method. In general, the application is expected to keep track of which pages it has allocated.
            </para>
            </remarks>
        </member>
        <member name="P:Storage.IPageStorage.IsReadOnly">
            <summary>
            Is this <see cref="T:Storage.IPageStorage"/> read-only?
            </summary>
            <remarks>
            The implementation must not allow this property to change in runtime. Once
            the instance has been constructed, this property must maintain the same value.
            </remarks>
        </member>
        <member name="P:Storage.IPageStorage.IsCapacityFixed">
            <summary>
            Is the <see cref="P:Storage.IPageStorage.PageCapacity"/> a fixed constant?
            </summary>
            <remarks>
            <para>
            This property defines whether the <see cref="P:Storage.IPageStorage.PageCapacity"/> is a fixed constant,
            meaning it cannot be changed via <see cref="M:Storage.IPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
            or <see cref="M:Storage.IPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>.
            The implementation must not allow this property to change in runtime. Once
            the instance has been constructed, this property must maintain the same value. However,
            it may change across different instances for the same payload source object (such as a file).
            </para>
            <para>
            If <see cref="P:Storage.IPageStorage.IsReadOnly"/> is true, then this property must also be true.
            </para>
            </remarks>
            <seealso cref="P:Storage.IPageStorage.IsReadOnly"/>
        </member>
        <member name="P:Storage.IPageStorage.PageCapacity">
            <summary>
            The total capacity, measured in the number of pages.
            </summary>
            <remarks>
            <para>
            This property refers to the sum of all allocated and unallocated pages. If 
            <see cref="P:Storage.IPageStorage.IsCapacityFixed"/> is false, then the page capacity can be 
            increased via <see cref="M:Storage.IPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
            and decreased via <see cref="M:Storage.IPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>.
            </para>
            </remarks>
            <seealso cref="P:Storage.IPageStorage.IsCapacityFixed"/>
            <seealso cref="M:Storage.IPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
            <seealso cref="M:Storage.IPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
        </member>
        <member name="P:Storage.IPageStorage.AllocatedPageCount">
            <summary>
            The total number of pages that are currently allocated.
            </summary>
            <seealso cref="P:Storage.IPageStorage.PageCapacity"/>
            <seealso cref="M:Storage.IPageStorage.TryAllocatePage(System.Int64@)"/>
            <seealso cref="M:Storage.IPageStorage.FreePage(System.Int64)"/>
            <remarks>
            Note that this property may potentially be larger than the number of pages
            that have been allocated <em>by the application</em>, since some
            implementations may perform some internal page allocations for their
            various needs. In general, the application is expected to keep track of 
            which pages it has allocated.
            </remarks>
        </member>
        <member name="P:Storage.IPageStorage.PageSize">
            <summary>
            The size of each page's payload, measured in bytes.
            </summary>
            <remarks>
            The implementation must not allow this property to change in runtime. Once
            the instance has been constructed, this property must maintain the same value.
            Furthermore, if the implementation is based on a non-volatile storage object,
            such as a file, then this property must maintain the same value even across instances
            for the same object. For example, the implementation may read this value from a 
            read-only header in a file.
            </remarks>
        </member>
        <member name="P:Storage.IPageStorage.EntryPageIndex">
            <summary>
            The index of the application-defined 'entry page,' or null.
            </summary>
            <remarks>
            <para>
            This property is intended as a utility for an application. Consider that the application
            initially does not necessarily know where to start 'finding' data. It is not recommended
            that the application simply assumes the 'entry' page is at a constant index such as zero,
            since the interface technically allows pages to be allocated in any order. Instead, the
            application is expected to store the 'entry page' index in this property. Then, when the
            application first initializes, it will open the 'entry page' specified by this property,
            and that 'entry page' will contain whatever the application needs for initialization.
            </para>
            <para>
            For an example of how this property is useful, consider that the application is storing a
            tree in the storage, where each allocated page is a node. When the application is initialized,
            it will need to know where the root node's page is located. The application would use this property
            to store the index of the root node's page.
            </para>
            <para>
            This property can be used to store any non-negative value, even if it does not refer to an
            allocated page, or null. It is the application's responsibility to avoid assigning an invalid
            index.
            </para>
            <para>
            If a negative value is assigned, an <see cref="T:System.ArgumentOutOfRangeException"/> will be thrown.
            </para>
            <para>
            If <see cref="P:Storage.IPageStorage.IsReadOnly"/> is true and the application assigns a value to this property, then
            an <see cref="T:System.InvalidOperationException"/> will be thrown.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when assigning a negative value.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when assigning a value when <see cref="P:Storage.IPageStorage.IsReadOnly"/>
            is true.</exception>
        </member>
        <member name="M:Storage.IPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)">
            <summary>
            Attempts to increase the <see cref="P:Storage.IPageStorage.PageCapacity"/> by creating
            space for more unallocated pages.
            </summary>
            <param name="additionalPageCount">The desired additional number of unallocated 
            pages to create.</param>
            <param name="progressReporter"><see cref="T:System.IProgress`1"/> that receives a
            <see cref="T:Storage.ProgressReport"/> as the inflation progresses. May be null, in 
            which case progress will not be reported.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> that allows
            the application to cancel the inflation. Cancellation will cause the inflation
            to stop at the nearest 'safe' position to avoid data corruption. This means
            that some pages may have already been created upon cancellation, but not 
            necessarily as many as were requested. Upon cancellation, this method will
            NOT throw any <see cref="T:System.Exception"/>, but will instead return the additional
            number of pages that have been created, if any, before the operation was
            cancelled.</param>
            <returns>The actual number of additional unallocated pages that were created. 
            This may be more or less than the desired <paramref name="additionalPageCount"/>, 
            and may even be zero.</returns>
            <remarks>
            <para>
            This method will attempt to increase the <see cref="P:Storage.IPageStorage.PageCapacity"/> by creating more 
            unallocated pages in the storage. Calling this method will <em>not</em> affect any
            currently allocated pages, except potentially if an <see cref="T:System.Exception"/> is thrown,
            which may indicate data corruption. The capacity is only ever increased by adding more 
            unallocated pages to the end of the storage (because adding unallocated pages
            anywhere else would risk affecting the indices of some allocated pages). Note that 
            the implementation may be unable to create the desired number of additional 
            unallocated pages (<paramref name="additionalPageCount"/>), in  which case it will 
            only create what is possible. If the implementation is unable to create space for even 
            one more unallocated page, then zero will be returned. Upon cancellation via the
            <paramref name="cancellationToken"/>, this method will return the additional
            number of pages that were created before the operation was cancelled. 
            Cancellation will <em>not</em> cause data corruption.
            </para>
            <para>
            If <see cref="P:Storage.IPageStorage.IsCapacityFixed"/> is true, then the implementation is required to
            throw an <see cref="T:System.InvalidOperationException"/>.
            </para>
            <para>
            If <paramref name="additionalPageCount"/> is a negative number, then the implementation
            will throw an <see cref="T:System.ArgumentOutOfRangeException"/> and the storage will remain
            unchanged. To decrease the <see cref="P:Storage.IPageStorage.PageCapacity"/>, use the 
            <see cref="M:Storage.IPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/> method instead.
            </para>
            <para>
            If any <see cref="T:System.Exception"/> is thrown, except the two that were described above, then
            the application is expected to assume that some data has been corrupted.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.IPageStorage.IsCapacityFixed"/>
            is true.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="additionalPageCount"/>
            is less than zero.</exception>
            <seealso cref="P:Storage.IPageStorage.IsCapacityFixed"/>
            <seealso cref="P:Storage.IPageStorage.PageCapacity"/>
            <seealso cref="M:Storage.IPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Storage.IPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)">
            <summary>
            Attempts to decrease the <see cref="P:Storage.IPageStorage.PageCapacity"/>, by removing unallocated pages
            at the very end of this <see cref="T:Storage.IPageStorage"/>.
            </summary>
            <param name="removePageCount">The desired number of unallocated pages to remove.</param>
            <param name="progressReporter"><see cref="T:System.IProgress`1"/> that receives a
            <see cref="T:Storage.ProgressReport"/> as the deflation progresses. May be null, in which
            case progress will not be reported.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> that allows the
            application to cancel the deflation operation. Cancellation will cause the
            deflation to stop at the nearest 'safe' position to avoid data corruption. This
            means that some pages may have been removed upon cancellation, but not necessarily
            as many as were requested. Upon cancellation, this method will NOT throw an
            <see cref="T:System.Exception"/>, but will instead return the number of pages that have
            been removed before cancellation.</param>
            <returns>The actual number of unallocated pages that were removed. This may be more or
            less than <paramref name="removePageCount"/>, and may even be zero.</returns>
            <remarks>
            <para>
            This method will attempt to decrease the <see cref="P:Storage.IPageStorage.PageCapacity"/> by removing
            unallocated pages at the very end of the storage. Calling this method will <em>not</em>
            affect any currently allocated pages, except potentially if an <see cref="T:System.Exception"/> is thrown,
            which may indicate data corruption. The capacity is only ever decreased by
            removing unallocated pages from the very end of the storage (because removing
            unallocated pages from anywhere else would risk changing the indices of currently
            allocated pages). If there is not a consecutive sequence of <paramref name="removePageCount"/>
            unallocated pages at the very end of the storage, then the implementation will not
            be able to decrease the <see cref="P:Storage.IPageStorage.PageCapacity"/> by that amount. In this case, the
            implementation will try to remove however many consecutively unallocated pages are 
            at the very end of the storage. If the very last page on the storage is currently
            allocated, then the implementation will not be able to decrease the <see cref="P:Storage.IPageStorage.PageCapacity"/>
            by any amount, and zero will be returned.
            </para>
            <para>
            Upon cancellation via the <paramref name="cancellationToken"/>, this method will
            return the number of pages that were removed before the operation was cancelled.
            Cancellation will <em>not</em> cause data corruption.
            </para>
            <para>
            If <see cref="P:Storage.IPageStorage.IsCapacityFixed"/> is true, then the implementation is required to
            throw an <see cref="T:System.InvalidOperationException"/>.
            </para>
            <para>
            If <paramref name="removePageCount"/> is a negative number, then the implementation
            will throw an <see cref="T:System.ArgumentOutOfRangeException"/> and the storage will remain
            unchanged. To increase the <see cref="P:Storage.IPageStorage.PageCapacity"/>, use the 
            <see cref="M:Storage.IPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/> method instead.
            </para>
            <para>
            If any <see cref="T:System.Exception"/> is thrown, except the two that were described above, then
            the application is expected to assume that some data has been corrupted.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.IPageStorage.IsCapacityFixed"/>
            is true.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="removePageCount"/>
            is less than zero.</exception>
            <seealso cref="P:Storage.IPageStorage.IsCapacityFixed"/>
            <seealso cref="P:Storage.IPageStorage.PageCapacity"/>
            <seealso cref="M:Storage.IPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Storage.IPageStorage.IsPageAllocated(System.Int64)">
            <summary>
            Checks whether a page is currently allocated.
            </summary>
            <param name="index">The index of the page.</param>
            <returns>True if the page is currently allocated, otherwise false.</returns>
            <remarks>
            <para>
            If <paramref name="index"/> is out of the range of all pages (allocated and unallocated),
            then false is returned. See <see cref="M:Storage.IPageStorage.IsPageOnStorage(System.Int64)"/>.
            </para>
            <para>
            Note that some implementations may perform internal allocations for their various needs, and
            so this method may return true for such pages. In general, the application should keep track
            of which pages it has allocated.
            </para>
            </remarks>
            <seealso cref="M:Storage.IPageStorage.IsPageOnStorage(System.Int64)"/>
            <seealso cref="M:Storage.IPageStorage.TryAllocatePage(System.Int64@)"/>
            <seealso cref="M:Storage.IPageStorage.FreePage(System.Int64)"/>
        </member>
        <member name="M:Storage.IPageStorage.IsPageOnStorage(System.Int64)">
            <summary>
            Checks whether a page exists (regardless of whether or not it is allocated)
            on the storage.
            </summary>
            <param name="index">The index of the page.</param>
            <returns>True if <paramref name="index"/> is greater than or equal to zero and less
            than <see cref="P:Storage.IPageStorage.PageCapacity"/>, otherwise false.</returns>
            <seealso cref="M:Storage.IPageStorage.IsPageAllocated(System.Int64)"/>
            <seealso cref="P:Storage.IPageStorage.PageCapacity"/>
        </member>
        <member name="M:Storage.IPageStorage.TryAllocatePage(System.Int64@)">
            <summary>
            Attempts to allocate a page.
            </summary>
            <param name="index">Upon success, assigned to the index of the allocated page. Upon
            failure, assigned to -1.</param>
            <returns>True if a page was successfully allocated. False only indicates that there
            is no capacity to allocate a new page (<see cref="P:Storage.IPageStorage.AllocatedPageCount"/> equals
            <see cref="P:Storage.IPageStorage.PageCapacity"/>).</returns>
            <remarks>
            <para>
            This method will find an unallocated page within the <see cref="P:Storage.IPageStorage.PageCapacity"/>, and
            mark that page as allocated. The application is expected to keep track of the page
            via the assigned <paramref name="index"/>. If there is no unallocated page, then
            false will be returned and nothing will change.
            </para>
            <para>
            Note that this method will never change the <see cref="P:Storage.IPageStorage.PageCapacity"/>. If there are
            no unallocated pages, then the only option to allocate a new page is to call
            <see cref="M:Storage.IPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>.
            </para>
            <para>
            Also note that the 'initial payload' of a newly allocated page is considered undefined.
            The implementation is not required to initialize the payload of an allocated page, as it
            is expected that doing so could consume a lot of time, depending on the <see cref="P:Storage.IPageStorage.PageSize"/>.
            For example, the 'initial payload' may simply be the data that was previously stored on
            the page when it was allocated at a previous time. Or, the implementation may use unallocated
            pages to store internal metadata.
            </para>
            <para>
            If <see cref="P:Storage.IPageStorage.IsReadOnly"/> is true, then an <see cref="T:System.InvalidOperationException"/>
            will be thrown and nothing will change.
            </para>
            <para>
            If any <see cref="T:System.Exception"/> is thrown, except the <see cref="T:System.InvalidOperationException"/>
            described above, then the application is expected to assume that some data has been corrupted.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.IPageStorage.IsReadOnly"/> is true.</exception>
            <seealso cref="M:Storage.IPageStorage.FreePage(System.Int64)"/>
            <seealso cref="P:Storage.IPageStorage.IsReadOnly"/>
            <seealso cref="M:Storage.IPageStorage.IsPageAllocated(System.Int64)"/>
            <seealso cref="P:Storage.IPageStorage.AllocatedPageCount"/>
        </member>
        <member name="M:Storage.IPageStorage.FreePage(System.Int64)">
            <summary>
            Deallocates a page.
            </summary>
            <param name="index">The index of the page to deallocate.</param>
            <returns>True if the page was deallocated, false if it was already
            unallocated when this method was called.</returns>
            <remarks>
            <para>
            If the specified page was allocated when this method was called, then 
            it will be marked as deallocated, and the <see cref="P:Storage.IPageStorage.AllocatedPageCount"/>
            will decrease by one, but <see cref="P:Storage.IPageStorage.PageCapacity"/> will remain unchanged.
            If the specified page was not allocated, then false is returned and 
            nothing will change.
            </para>
            <para>
            Note that the implementation is <em>not</em> expected to erase any payload that has been
            stored by the page. If the application has written information that it wishes to 
            be erased, it must do so manually before calling this method. Otherwise, the payload
            may exist on the storage, and it may even be leaked to the application in a future 
            <see cref="M:Storage.IPageStorage.TryAllocatePage(System.Int64@)"/> call, since that page may contain the payload 
            that was stored in this to-be-freed page.
            </para>
            <para>
            If <see cref="P:Storage.IPageStorage.IsReadOnly"/> is true, then an <see cref="T:System.InvalidOperationException"/>
            will be thrown and nothing will change.
            </para>
            <para>
            If <paramref name="index"/> is out of the range of valid indices (negative or not less
            than <see cref="P:Storage.IPageStorage.PageCapacity"/>, see <see cref="M:Storage.IPageStorage.IsPageOnStorage(System.Int64)"/>), then an
            <see cref="T:System.ArgumentOutOfRangeException"/> will be thrown and nothing will change.
            </para>
            <para>
            If any <see cref="T:System.Exception"/> is thrown, except the two described above, then the
            application is expected to assume that some data has been corrupted.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.IPageStorage.IsReadOnly"/> is true.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="index"/> is negative or
            greater than or equal to <see cref="P:Storage.IPageStorage.PageCapacity"/>. See <see cref="M:Storage.IPageStorage.IsPageOnStorage(System.Int64)"/>.</exception>
            <seealso cref="M:Storage.IPageStorage.TryAllocatePage(System.Int64@)"/>
            <seealso cref="P:Storage.IPageStorage.IsReadOnly"/>
            <seealso cref="M:Storage.IPageStorage.IsPageAllocated(System.Int64)"/>
            <seealso cref="P:Storage.IPageStorage.AllocatedPageCount"/>
        </member>
        <member name="M:Storage.IPageStorage.ReadFrom(System.Int64,System.Int64,System.Byte[],System.Int64,System.Int64)">
            <summary>
            Reads payload from an allocated page.
            </summary>
            <param name="pageIndex">The index of the allocated page.</param>
            <param name="srcOffset">The source offset within the page's payload, measured in bytes.</param>
            <param name="buffer">The destination buffer.</param>
            <param name="dstOffset">The destination offset within the destination <paramref name="buffer"/>,
            measured in bytes.</param>
            <param name="length">The number of bytes to read.</param>
            <remarks>
            <para>
            If <paramref name="pageIndex"/> refers to an unallocated page, then an
            <see cref="T:System.InvalidOperationException"/> will be thrown.
            </para>
            <para>
            If any of the payload position/length arguments are out of their valid range, an
            <see cref="T:System.ArgumentOutOfRangeException"/> will be thrown.
            </para>
            <para>
            If <paramref name="buffer"/> is null, then an <see cref="T:System.ArgumentNullException"/> will
            be thrown.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <paramref name="pageIndex"/> does not refer to
            an allocated page.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="srcOffset"/>,
            <paramref name="dstOffset"/>, or <paramref name="length"/> is negative; or if the sum of
            <paramref name="srcOffset"/> and <paramref name="length"/> is greater than <see cref="P:Storage.IPageStorage.PageSize"/>;
            or if the sum of <paramref name="dstOffset"/> and <paramref name="length"/> is greater than
            the <paramref name="buffer"/> size.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <seealso cref="M:Storage.IPageStorage.WriteTo(System.Int64,System.Int64,System.Byte[],System.Int64,System.Int64)"/>
            <seealso cref="M:Storage.IPageStorage.IsPageAllocated(System.Int64)"/>
        </member>
        <member name="M:Storage.IPageStorage.WriteTo(System.Int64,System.Int64,System.Byte[],System.Int64,System.Int64)">
            <summary>
            Writes payload to an allocated page.
            </summary>
            <param name="pageIndex">The index of the allocated page.</param>
            <param name="dstOffset">The destination offset within the page's payload, measured in 
            bytes.</param>
            <param name="buffer">The source buffer.</param>
            <param name="srcOffset">The source offset within the source <paramref name="buffer"/>,
            measured in bytes.</param>
            <param name="length">The number of bytes to write.</param>
            <remarks>
            <para>
            If <paramref name="pageIndex"/> refers to an unallocated page, or if <see cref="P:Storage.IPageStorage.IsReadOnly"/>
            is true, then an <see cref="T:System.InvalidOperationException"/> will be thrown and nothing
            will change.
            </para>
            <para>
            If any of the payload position/length arguments are out of their valid range, an
            <see cref="T:System.ArgumentOutOfRangeException"/> will be thrown and nothing will change.
            </para>
            <para>
            If <paramref name="buffer"/> is null, then an <see cref="T:System.ArgumentNullException"/>
            will be thrown.
            </para>
            <para>
            If any <see cref="T:System.Exception"/> is thrown, except those described above, then the
            application is expected to assume that some data may have been corrupted.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <paramref name="pageIndex"/> refers
            to an unallocated page, or if <see cref="P:Storage.IPageStorage.IsReadOnly"/> is true.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="srcOffset"/>,
            <paramref name="dstOffset"/>, or <paramref name="length"/> is negative; or if
            the sum of <paramref name="dstOffset"/> and <paramref name="length"/> is greater
            than <see cref="P:Storage.IPageStorage.PageSize"/>; or if the sum of <paramref name="srcOffset"/> and
            <paramref name="length"/> is greater than the <paramref name="buffer"/> size.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <seealso cref="M:Storage.IPageStorage.ReadFrom(System.Int64,System.Int64,System.Byte[],System.Int64,System.Int64)"/>
            <seealso cref="P:Storage.IPageStorage.IsReadOnly"/>
            <seealso cref="M:Storage.IPageStorage.IsPageAllocated(System.Int64)"/>
        </member>
        <member name="T:Storage.ISafeResizable">
            <summary>
            Interface that represents something with payload that can be resized safely.
            </summary>
            <remarks>
            <para>
            Resizing 'safely' does not mean that the payload can be resized to any value.
            Obviously this is likely impossible (a file cannot be resized to 2^64 bytes,
            for example). Instead, it means that the implementation is able to try
            to resize the payload, and if it fails, it ensures that the payload remains
            at its original size and its data remains unchanged.
            </para>
            <para>
            Note that the implementation may be in a read-only or fixed-size state,
            in which case this interface is practically useless. This may seem like a 
            contradiction: Why would an object inherit this interface if it is read-only? 
            The answer is that writability or resizability may depend on runtime arguments. 
            It is generally expected that the caller/application already knows whether the 
            contained payload is read-only or fixed-size, and would thus avoid using the
            members defined in this interface if so. If the application attempts to resize
            the payload of a read-only or fixed-size instance (via <see cref="M:Storage.ISafeResizable.TrySetSize(System.Int64)"/>), 
            then the implementation will throw an <see cref="T:System.InvalidOperationException"/>.
            </para>
            </remarks>
        </member>
        <member name="P:Storage.ISafeResizable.MaxSize">
            <summary>
            The approximate maximum payload size, measured in bytes, or null if unknown.
            </summary>
            <remarks>
            This property represents a best-guess of the maximum payload size, 
            if it is known. The actual maximum payload size may be slightly more or
            less than this amount, if the implementation is unable to determine
            a confident maximum. Generally, the implementation should round down
            if it lacks confidence. If the implementation is unable to determine
            a reasonable guess, then it may return null instead.
            </remarks>
        </member>
        <member name="M:Storage.ISafeResizable.TrySetSize(System.Int64)">
            <summary>
            Attempts to safely resize the payload.
            </summary>
            <param name="size">The desired payload size, measured in bytes.</param>
            <returns>True if the payload was successfully resized, otherwise false.</returns>
            <remarks>
            <para>
            The implementation will try to resize the payload to the specified
            <paramref name="size"/>. If the resize fails, then false will be returned and
            the implementation must ensure that the original payload size and content remains
            unchanged. If for some reason the implementation is unable to prevent data corruption
            after a failed resize, then it must throw an <see cref="T:System.Exception"/> instead of returning
            false.
            </para>
            <para>
            When shrinking, data will only be removed from the very end of the payload. When increasing
            the size, undefined data will only be added to the very end of the payload. The original
            portion of the payload must remain unchanged (unless an <see cref="T:System.Exception"/> is thrown,
            indicating potential data corruption).
            </para>
            <para>
            When false is returned, it means that nothing has changed - the payload size and content
            is exactly what it was before this method was called. When true is returned, it means that
            the remaining portion of the original payload is exactly what was stored before this method
            was called and that the new size is exactly what was requested by the <paramref name="size"/>
            argument.
            </para>
            <para>
            If <paramref name="size"/> is less than zero, an <see cref="T:System.ArgumentOutOfRangeException"/>
            will be thrown. There is <em>no</em> strict upper limit which will result in an
            <see cref="T:System.ArgumentOutOfRangeException"/> being thrown, not even
            <see cref="P:Storage.ISafeResizable.MaxSize"/> (since that is just a best guess).
            </para>
            <para>
            The implementation may throw an <see cref="T:System.InvalidOperationException"/> if the payload
            is read-only or fixed-size. This may seem like a contradiction: Why would an object
            inherit this interface if it is read-only? The answer is that writability or resizability
            may depend on runtime arguments. It is generally expected that the caller already
            knows whether the contained payload is read-only or fixed-size, and would thus avoid
            calling this method if so.
            </para>
            <para>
            If any <see cref="T:System.Exception"/> is thrown, except the <see cref="T:System.ArgumentOutOfRangeException"/>
            and <see cref="T:System.InvalidOperationException"/> described above, then the application
            should expect that the resize operation has failed, and that it may have corrupted 
            the payload.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="size"/>
            is less than zero.</exception>
            <exception cref="T:System.InvalidOperationException">May be thrown by implementation if
            the payload is read-only or fixed-size.</exception>
        </member>
        <member name="T:Storage.ProgressReport">
            <summary>
            Structure that reports the current progress of an operation.
            </summary>
        </member>
        <member name="P:Storage.ProgressReport.Target">
            <summary>
            The target value, or null if unknown.
            </summary>
        </member>
        <member name="P:Storage.ProgressReport.Current">
            <summary>
            The current value.
            </summary>
            <remarks>
            This should always be at least zero, and at most <see cref="P:Storage.ProgressReport.Target"/> (if it is known).
            </remarks>
        </member>
        <member name="M:Storage.ProgressReport.#ctor(System.Int64,System.Nullable{System.Int64})">
            <summary>
            <see cref="T:Storage.ProgressReport"/> constructor.
            </summary>
            <param name="current">The current value. See <see cref="P:Storage.ProgressReport.Current"/>.</param>
            <param name="target">The target value, or null if unknown.</param>
        </member>
        <member name="T:Storage.ProgressReporter">
            <summary>
            Delegated <see cref="T:System.IProgress`1"/>.
            </summary>
        </member>
        <member name="T:Storage.ProgressReporter.ReportHandler">
            <summary>
            Delegate that handles a <see cref="T:Storage.ProgressReport"/>.
            </summary>
            <param name="report">The <see cref="T:Storage.ProgressReport"/> that describes the current progress.</param>
        </member>
        <member name="M:Storage.ProgressReporter.#ctor(Storage.ProgressReporter.ReportHandler)">
            <summary>
            <see cref="T:Storage.ProgressReporter"/> constructor.
            </summary>
            <param name="reportHandler">The <see cref="T:Storage.ProgressReporter.ReportHandler"/> that will handle the <see cref="T:Storage.ProgressReport"/>s.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="reportHandler"/> is null.</exception>
        </member>
        <member name="M:Storage.ProgressReporter.Report(Storage.ProgressReport)">
            <summary>
            Reports the current progress.
            </summary>
            <param name="value">The <see cref="T:Storage.ProgressReport"/>.</param>
        </member>
        <member name="T:Storage.StreamingPageStorage">
            <summary>
            <see cref="T:Storage.IPageStorage"/> implementation where the base storage is a <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="F:Storage.StreamingPageStorage.UnallocatedPageLinkSize">
            <summary>
            The size that is used to link together 'unallocated' pages.
            When a page is unallocated, its payload is used to form a linked
            list node of 'unallocated' pages. This means it must store the
            index of the previous unallocated page (or -1 if none), and the
            index of the next unallocated page (or -1 if none).
            </summary>
        </member>
        <member name="F:Storage.StreamingPageStorage.HeaderSize">
            <summary>
            The size, in bytes, of the header.
            </summary>
        </member>
        <member name="F:Storage.StreamingPageStorage.MinPageSize">
            <summary>
            The minimum page payload size, measured in bytes.
            </summary>
        </member>
        <member name="M:Storage.StreamingPageStorage.GetRequiredStreamSize(System.Int64,System.Int64)">
            <summary>
            Gets the required size of a <see cref="T:System.IO.Stream"/> to contain a <see cref="T:Storage.StreamingPageStorage"/> with
            a particular page size and capacity.
            </summary>
            <param name="pageSize">The size, in bytes, of each page's payload.</param>
            <param name="pageCapacity">The number of pages.</param>
            <returns>The required size, measured in bytes.</returns>
            <seealso cref="F:Storage.StreamingPageStorage.HeaderSize"/>
        </member>
        <member name="M:Storage.StreamingPageStorage.GetPageCapacityForStreamSize(System.Int64,System.Int64)">
            <summary>
            Determines the page capacity that can fit in a specific <see cref="T:System.IO.Stream"/> size using
            a specific page size.
            </summary>
            <param name="streamSize">The size of the <see cref="T:System.IO.Stream"/>, measured in bytes.</param>
            <param name="pageSize">The size of each page's payload, measured in bytes.</param>
            <returns>The maximum number of pages that can be stored in a <see cref="T:Storage.StreamingPageStorage"/>
            based on a <see cref="T:System.IO.Stream"/> with the specified <paramref name="streamSize"/>.</returns>
        </member>
        <member name="P:Storage.StreamingPageStorage.PageSize">
            <summary>
            The size, in bytes, of each page's payload.
            </summary>
            <seealso cref="F:Storage.StreamingPageStorage.MinPageSize"/>
        </member>
        <member name="P:Storage.StreamingPageStorage.IsReadOnly">
            <summary>
            Is this <see cref="T:Storage.IPageStorage"/> readonly?
            </summary>
        </member>
        <member name="P:Storage.StreamingPageStorage.IsCapacityFixed">
            <summary>
            Is the <see cref="P:Storage.StreamingPageStorage.PageCapacity"/> a fixed constant?
            </summary>
            <remarks>
            This property defines whether the <see cref="P:Storage.StreamingPageStorage.PageCapacity"/> is a fixed constant,
            meaning it cannot be changed via <see cref="M:Storage.StreamingPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/> or 
            <see cref="M:Storage.StreamingPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>. It cannot be changed after the 
            <see cref="T:Storage.StreamingPageStorage"/> has been instantiated, however it may change across different instances for the same
            base <see cref="T:System.IO.Stream"/>.
            </remarks>
            <seealso cref="P:Storage.StreamingPageStorage.IsReadOnly"/>
        </member>
        <member name="P:Storage.StreamingPageStorage.EntryPageIndex">
            <summary>
            The index of the application-defined 'entry page,' or null.
            </summary>
            <remarks>
            <para>
            This property is intended as a utility for an application. Consider that the application
            initially does not necessarily know where to start 'finding' data. It is not recommended
            that the application simply assumes the 'entry' page is at a constant index such as zero,
            since the interface technically allows pages to be allocated in any order. Instead, the
            application is expected to store the 'entry page' index in this property. Then, when the
            application first initializes, it will open the 'entry page' specified by this property,
            and that 'entry page' will contain whatever the application needs for initialization.
            </para>
            <para>
            For an example of how this property is useful, consider that the application is storing a
            tree in the storage, where each allocated page is a node. When the application is initialized,
            it will need to know where the root node's page is located. The application would use this property
            to store the index of the root node's page.
            </para>
            <para>
            This property can be used to store any non-negative value, even if it does not refer to an
            allocated page, or null. It is the application's responsibility to avoid assigning an invalid
            index.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when assigning a negative value.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when assigning a value when <see cref="P:Storage.StreamingPageStorage.IsReadOnly"/>
            is true.</exception>
        </member>
        <member name="P:Storage.StreamingPageStorage.PageCapacity">
            <summary>
            The total capacity, measured in the number of pages.
            </summary>
            <remarks>
            <para>
            This property refers to the sum of all allocated and unallocated pages. If 
            <see cref="P:Storage.StreamingPageStorage.IsCapacityFixed"/> is false, then the page capacity can be 
            increased via <see cref="M:Storage.StreamingPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
            and decreased via <see cref="M:Storage.StreamingPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>.
            </para>
            </remarks>
            <seealso cref="P:Storage.StreamingPageStorage.IsCapacityFixed"/>
            <seealso cref="M:Storage.StreamingPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
            <seealso cref="M:Storage.StreamingPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
        </member>
        <member name="P:Storage.StreamingPageStorage.AllocatedPageCount">
            <summary>
            The total number of pages that are currently allocated by the application.
            </summary>
            <seealso cref="P:Storage.StreamingPageStorage.PageCapacity"/>
            <seealso cref="M:Storage.StreamingPageStorage.TryAllocatePage(System.Int64@)"/>
            <seealso cref="M:Storage.StreamingPageStorage.FreePage(System.Int64)"/>
        </member>
        <member name="M:Storage.StreamingPageStorage.Validate(System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)">
            <summary>
            Validates the header, and scans each unallocated page to ensure that the
            'Unallocated Page List' is valid.
            </summary>
            <param name="progressReporter"><see cref="T:System.IProgress`1"/> that receives a
            <see cref="T:Storage.ProgressReport"/> report as progress is made.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> that allows the
            application to cancel the validation operation. Upon cancellation, this
            method will unblock and no <see cref="T:System.Exception"/> will be thrown.</param>
            <returns>True if everything was successfully validated, false if
            the operation was cancelled via <paramref name="cancellationToken"/>.
            False does <em>not</em> indicate corrupt data, corrupt data is only
            indicated via an <see cref="T:System.Exception"/>.</returns>
            <remarks>
            <para>
            This method may be called by the application to rule out some causes of 
            corruption. Note that this may not catch all indicators of corruption, it
            primarily focuses on corruption relating to the 'Unallocated Page List'.
            The application-defined payload within each page will <em>not</em> be
            validated.
            </para>
            <para>
            Note that this method may block for a considerable amount of time,
            and all other methods/properties may be forced to wait in the
            meantime.
            </para>
            <para>
            Upon success, this method returns true. Upon cancellation, false is returned.
            If data corruption is found, any <see cref="T:System.Exception"/> may be thrown. Most
            corruption will be indicated via a <see cref="T:Storage.Data.CorruptDataException"/>.
            </para>
            </remarks>
            <exception cref="T:Storage.Data.CorruptDataException">Thrown if corrupt data is found. Note that
            other <see cref="T:System.Exception"/>s may also indicate corrupt data.</exception>
        </member>
        <member name="M:Storage.StreamingPageStorage.Load(System.IO.Stream,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Loads an existing <see cref="T:Storage.StreamingPageStorage"/> from a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> that contains the <see cref="T:Storage.StreamingPageStorage"/> data.
            Must contain at least <see cref="F:Storage.StreamingPageStorage.HeaderSize"/> bytes, <see cref="P:System.IO.Stream.CanRead"/> and
            <see cref="P:System.IO.Stream.CanSeek"/> must be true, if <paramref name="isReadOnly"/> is false then
            <see cref="P:System.IO.Stream.CanWrite"/> must also be true. If <paramref name="isCapacityFixed"/> is false,
            then this stream must also be resizable (either via <see cref="M:System.IO.Stream.SetLength(System.Int64)"/> or
            <see cref="M:Storage.ISafeResizable.TrySetSize(System.Int64)"/>). If it is likely that this <see cref="T:System.IO.Stream"/> will
            be resized, then it is highly recommended that it inherit the <see cref="T:Storage.ISafeResizable"/> interface.</param>
            <param name="isReadOnly">Should the <see cref="T:Storage.StreamingPageStorage"/> be opened in read-only mode? If 
            <paramref name="stream"/> is read-only, then this argument must be true.</param>
            <param name="isCapacityFixed">Should the <see cref="T:Storage.StreamingPageStorage"/> be opened in fixed-capacity 
            mode? If <paramref name="isReadOnly"/> is true, then this argument must also be true.</param>
            <param name="leaveStreamOpen">Should the <paramref name="stream"/> remain open (un-disposed) after this
            <see cref="T:Storage.StreamingPageStorage"/> is disposed? If false, then when this <see cref="T:Storage.StreamingPageStorage"/>
            is disposed, the <paramref name="stream"/>'s <see cref="M:System.IO.Stream.Dispose"/> method will be called.</param>
            <returns>The resulting <see cref="T:Storage.StreamingPageStorage"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="stream"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="stream"/> is not readable or
            seekable; or if <paramref name="stream"/> has less than <see cref="F:Storage.StreamingPageStorage.HeaderSize"/> bytes;
            or if <paramref name="stream"/> is read-only while <paramref name="isReadOnly"/> is false;
            or if <paramref name="isReadOnly"/> is true while <paramref name="isCapacityFixed"/> is false.</exception>
            <exception cref="T:Storage.Data.CorruptDataException">Thrown if corrupt data is found. Note that other
            <see cref="T:System.Exception"/>s may also be thrown if corrupt data is found.</exception>
        </member>
        <member name="M:Storage.StreamingPageStorage.Create(System.IO.Stream,System.Int64,System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken,System.Boolean,System.Int64)">
            <summary>
            Creates a new <see cref="T:Storage.StreamingPageStorage"/> on a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> in which to create the new 
            <see cref="T:Storage.StreamingPageStorage"/>. Must be readable, resizable (via <see cref="M:System.IO.Stream.SetLength(System.Int64)"/>, 
            writable, and seekable. It is highly recommended that this <see cref="T:System.IO.Stream"/> 
            inherit the <see cref="T:Storage.ISafeResizable"/> interface, even though it is 
            not directly used by this method (it may be used after creation).</param>
            <param name="pageSize">The size of each page's payload, measured in bytes. Must be 
            at least <see cref="F:Storage.StreamingPageStorage.MinPageSize"/> bytes.</param>
            <param name="initialCapacity">The initial capacity, measured in the number of pages.</param>
            <param name="progressReporter"><see cref="T:System.IProgress`1"/> that receives a 
            <see cref="T:Storage.ProgressReport"/> structure as progress is made. May be null, in which 
            case progress will not be reported.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> that may be used to cancel 
            the creation process.</param>
            <param name="leaveStreamOpen">Should the <paramref name="stream"/> remain open (un-disposed)
            after this <see cref="T:Storage.StreamingPageStorage"/> is disposed? If false, then when this
            <see cref="T:Storage.StreamingPageStorage"/> is disposed, the <paramref name="stream"/>'s
            <see cref="M:System.IO.Stream.Dispose"/> method will be called.</param>
            <param name="maxResizeIncrement">The maximum increment, measured in bytes, that will be
            used to resize the <paramref name="stream"/>. Must be at least one. Using a value that is
            too small may result in more frequent <see cref="M:System.IO.Stream.SetLength(System.Int64)"/> calls, but using
            a value that is too large may result in the <see cref="M:System.IO.Stream.SetLength(System.Int64)"/> call
            blocking for a long time, delaying any potential cancellation via the
            <paramref name="cancellationToken"/>.</param>
            <returns>The resulting <see cref="T:Storage.StreamingPageStorage"/> instance.</returns>
            <remarks>
            <para>
            This method will create a new <see cref="T:Storage.StreamingPageStorage"/> instance with
            a <see cref="P:Storage.IPageStorage.PageCapacity"/> of <paramref name="initialCapacity"/>, all of which
            will be unallocated pages. The <see cref="P:Storage.IPageStorage.EntryPageIndex"/> will be initialized
            to null. Some data in the <paramref name="stream"/> will be overwritten, but some of it may leak
            to freshly allocated pages.
            </para>
            <para>
            If the <paramref name="stream"/> is not exactly the required size (see <see cref="M:Storage.StreamingPageStorage.GetRequiredStreamSize(System.Int64,System.Int64)"/>),
            then it will be incrementally resized. The increment is determined by the <paramref name="maxResizeIncrement"/>
            argument (which is measured as an absolute value).
            </para>
            <para>
            Upon cancellation, an <see cref="T:System.OperationCanceledException"/> will be thrown and the application
            must assume that everything that has been written to the <paramref name="stream"/> is undefined data.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="stream"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="stream"/>'s <see cref="P:System.IO.Stream.CanRead"/>,
            <see cref="P:System.IO.Stream.CanWrite"/>, or <see cref="P:System.IO.Stream.CanSeek"/> property is false.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="pageSize"/> is less than
            <see cref="F:Storage.StreamingPageStorage.MinPageSize"/>, or if <paramref name="initialCapacity"/> is less than zero, or if
            <paramref name="maxResizeIncrement"/> is less than one.</exception>
            <exception cref="T:System.OperationCanceledException">Thrown if the operation was cancelled via the
            <paramref name="cancellationToken"/>.</exception>
        </member>
        <member name="M:Storage.StreamingPageStorage.CreateFixed(System.IO.Stream,System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Creates a fixed-capacity <see cref="T:Storage.StreamingPageStorage"/> on a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> in which to create the new
            <see cref="T:Storage.StreamingPageStorage"/>. Must be readable, writable, and seekable, but not
            necessarily resizable (<see cref="M:System.IO.Stream.SetLength(System.Int64)"/> will <em>not</em> be called).</param>
            <param name="pageSize">The size, in bytes, of each page's payload. Must be at lease
            <see cref="F:Storage.StreamingPageStorage.MinPageSize"/> bytes.</param>
            <param name="progressReporter"><see cref="T:System.IProgress`1"/> that receives a 
            <see cref="T:Storage.ProgressReport"/> structure as progress is made. May be null, in which 
            case progress will not be reported.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> that may be used to cancel 
            the creation process.</param>
            <param name="leaveStreamOpen">Should the <paramref name="stream"/> remain open (un-disposed)
            after this <see cref="T:Storage.StreamingPageStorage"/> is disposed? If false, then when this
            <see cref="T:Storage.StreamingPageStorage"/> is disposed, the <paramref name="stream"/>'s
            <see cref="M:System.IO.Stream.Dispose"/> method will be called.</param>
            <returns>The resulting <see cref="T:Storage.StreamingPageStorage"/> instance.</returns>
            <remarks>
            <para>
            This method will create a new <see cref="T:Storage.StreamingPageStorage"/> instance with
            a <see cref="P:Storage.StreamingPageStorage.PageCapacity"/> based on the size of the <paramref name="stream"/> (see
            <see cref="M:Storage.StreamingPageStorage.GetPageCapacityForStreamSize(System.Int64,System.Int64)"/>), all of which will be unallocated pages. 
            The <see cref="P:Storage.IPageStorage.EntryPageIndex"/> will be initialized to null. Some data in the 
            <paramref name="stream"/> will be overwritten, but some of it may leak to freshly allocated 
            pages.
            </para>
            <para>
            The resulting <see cref="T:Storage.StreamingPageStorage"/> will be fixed-capacity (<see cref="P:Storage.StreamingPageStorage.IsCapacityFixed"/> will
            be true). Since the <see cref="P:Storage.StreamingPageStorage.PageCapacity"/> will depend on the size of the <paramref name="stream"/>,
            and this method will not resize the <paramref name="stream"/>, it is the application's 
            responsibility to ensure that the <paramref name="stream"/> is large enough to be useful. 
            If it has less than <see cref="F:Storage.StreamingPageStorage.HeaderSize"/> bytes, this method will not be able to write a 
            valid header, so an <see cref="T:System.ArgumentException"/> will be thrown. If the <paramref name="stream"/>
            has enough bytes for the header, but not enough for even one full page, then <see cref="P:Storage.StreamingPageStorage.PageCapacity"/> 
            will be zero. This would not cause any problems, but would render the instance to be practically useless 
            to the application.
            </para>
            <para>
            Upon cancellation, an <see cref="T:System.OperationCanceledException"/> will be thrown and the application
            must assume that everything that has been written to the <paramref name="stream"/> is undefined data.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="stream"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="stream"/>'s <see cref="P:System.IO.Stream.CanRead"/>,
            <see cref="P:System.IO.Stream.CanWrite"/>, or <see cref="P:System.IO.Stream.CanSeek"/> property is false, or if its 
            <see cref="P:System.IO.Stream.Length"/> is less than <see cref="F:Storage.StreamingPageStorage.HeaderSize"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="pageSize"/> is less
            than <see cref="F:Storage.StreamingPageStorage.MinPageSize"/>.</exception>
            <exception cref="T:System.OperationCanceledException">Thrown if the operation is cancelled via
            the <paramref name="cancellationToken"/>.</exception>
        </member>
        <member name="M:Storage.StreamingPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)">
            <summary>
            Attempts to increase the <see cref="P:Storage.StreamingPageStorage.PageCapacity"/> by creating
            space for more unallocated pages.
            </summary>
            <param name="additionalPageCount">The desired additional number of unallocated 
            pages to create.</param>
            <param name="progressReporter"><see cref="T:System.IProgress`1"/> that receives a
            <see cref="T:Storage.ProgressReport"/> as the inflation progresses, or upon
            completion, cancellation, or failure. May be null, in which case progress
            will not be reported.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> that allows
            the application to cancel the inflation. Cancellation will cause the inflation
            to stop at the nearest 'safe' position to avoid data corruption. This means
            that some pages may have already been created upon cancellation, but not 
            necessarily as many as were requested. Upon cancellation, this method will
            NOT throw any <see cref="T:System.Exception"/>, but will instead return the additional
            number of pages that have been created, if any, before the operation was
            cancelled.</param>
            <returns>The actual number of additional unallocated pages that were created. 
            This may be less than the desired <paramref name="additionalPageCount"/>, 
            and may even be zero.</returns>
            <remarks>
            <para>
            This method will attempt to increase the <see cref="P:Storage.StreamingPageStorage.PageCapacity"/> by creating more 
            unallocated pages in the base <see cref="T:System.IO.Stream"/>. Calling this method will <em>not</em>
            affect any currently allocated pages, except potentially if an <see cref="T:System.Exception"/> is
            thrown, which may indicate data corruption. The capacity is only ever increased by adding
            more unallocated pages to the end of the base <see cref="T:System.IO.Stream"/>. Pages will be
            added progressively, and each addition will cause the base <see cref="T:System.IO.Stream"/>
            to be resized. If the base <see cref="T:System.IO.Stream"/> inherits the
            <see cref="T:Storage.ISafeResizable"/> interface (as is preferred), then its payload will 
            be resized via the <see cref="M:Storage.ISafeResizable.TrySetSize(System.Int64)"/> method. If this 
            call fails to resize the base <see cref="T:System.IO.Stream"/> to the required size (indicated
            by the return value being false), then this method will end early and return the 
            number of pages that were added before the resize failure. In this case, resize 
            failure does <em>not</em> indicate data corruption, but rather that the maximum limit 
            has been reached. Of course, if the <see cref="M:Storage.ISafeResizable.TrySetSize(System.Int64)"/> method
            does throw an <see cref="T:System.Exception"/>, then it will be passed to the caller, and the application
            should assume that the payload may have been corrupted. If the base <see cref="T:System.IO.Stream"/> does 
            <em>not</em> inherit the <see cref="T:Storage.ISafeResizable"/> interface, then the payload of the base 
            <see cref="T:System.IO.Stream"/> will be resized via the <see cref="M:System.IO.Stream.SetLength(System.Int64)"/> method. 
            Failure with this method is only indicated by it throwing an <see cref="T:System.Exception"/>, which will 
            be passed to the caller and the application should assume that payload may have been corrupted.
            </para>
            <para>
            The inflation operation may be cancelled by the application via the <paramref name="cancellationToken"/>.
            Cancellation will <em>not</em> cause data corruption, instead it will cause the inflation to stop
            at the nearest 'safe' position. Upon cancellation, this method will return the number of pages that
            have been added.
            </para>
            <para>
            If <see cref="P:Storage.StreamingPageStorage.IsCapacityFixed"/> is true, then an <see cref="T:System.InvalidOperationException"/> will be
            thrown.
            </para>
            <para>
            If <paramref name="additionalPageCount"/> is a negative number, then an 
            <see cref="T:System.ArgumentOutOfRangeException"/> will be thrown and the storage will remain
            unchanged. To decrease the <see cref="P:Storage.StreamingPageStorage.PageCapacity"/>, use the 
            <see cref="M:Storage.StreamingPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/> method instead.
            </para>
            <para>
            If any <see cref="T:System.Exception"/> is thrown, except the two that were described above, then
            the application is expected to assume that some data has been corrupted.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.StreamingPageStorage.IsCapacityFixed"/>
            is true.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="additionalPageCount"/>
            is less than zero.</exception>
            <seealso cref="P:Storage.StreamingPageStorage.IsCapacityFixed"/>
            <seealso cref="P:Storage.StreamingPageStorage.PageCapacity"/>
            <seealso cref="M:Storage.StreamingPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Storage.StreamingPageStorage.TryDeflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)">
            <summary>
            Attempts to decrease the <see cref="P:Storage.StreamingPageStorage.PageCapacity"/> by removing unallocated pages
            at the very end of the <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="removePageCount">The desired number of unallocated pages to remove.</param>
            <param name="progressReporter"><see cref="T:System.IProgress`1"/> that receives a
            <see cref="T:Storage.ProgressReport"/> as the deflation progresses, or upon
            completion, cancellation, or failure. May be null, in which case progress
            will not be reported.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> that allows the
            application to cancel the deflation operation. Cancellation will cause the
            deflation to stop at the nearest 'safe' position to avoid data corruption. This
            means that some pages may have been removed upon cancellation, but not necessarily
            as many as were requested. Upon cancellation, this method will NOT throw an
            <see cref="T:System.Exception"/>, but will instead return the number of pages that have
            been removed before cancellation.</param>
            <returns>The actual number of unallocated pages that were removed. This may be
            less than <paramref name="removePageCount"/>, and may even be zero.</returns>
            <remarks>
            <para>
            This method will attempt to decrease the <see cref="P:Storage.StreamingPageStorage.PageCapacity"/> by removing
            unallocated pages at the very end of the <see cref="T:System.IO.Stream"/>. Calling this method will <em>not</em>
            affect any currently allocated pages, except potentially if an <see cref="T:System.Exception"/> is thrown,
            which may indicate data corruption. The capacity is only ever decreased by
            removing unallocated pages from the very end of the storage. Pages will be removed
            progressively, and each removal will cause the base <see cref="T:System.IO.Stream"/> to be shrunk.
            If the base <see cref="T:System.IO.Stream"/> inherits the <see cref="T:Storage.ISafeResizable"/> interface (as
            is preferred), then its payload will be resized via the <see cref="M:Storage.ISafeResizable.TrySetSize(System.Int64)"/>
            method. If this call fails (indicated by a false return value), then this method will end
            early and return the number of pages that were removed before the resize failure. In this
            case, resize failure does <em>not</em> indicate data corruption. Of course, if the
            <see cref="M:Storage.ISafeResizable.TrySetSize(System.Int64)"/> method does throw an <see cref="T:System.Exception"/>, then
            it will be passed to the caller, and the application should assume that the payload may have
            been corrupted. If the base <see cref="T:System.IO.Stream"/> does <em>not</em> inherit the
            <see cref="T:Storage.ISafeResizable"/> interface, then the payload of the base <see cref="T:System.IO.Stream"/> will
            be resized via the <see cref="M:System.IO.Stream.SetLength(System.Int64)"/> method. Failure with this method is 
            only indicated by it throwing an <see cref="T:System.Exception"/>, which will be passed to the caller 
            and the application should assume that payload may have been corrupted.
            </para>
            <para>
            Note that this method will only remove consecutively unallocated pages at the end of the
            <see cref="T:System.IO.Stream"/>. If there is not a consecutive sequence of <paramref name="removePageCount"/>
            unallocated pages at the end, then this method will only remove the number of consecutive unallocated
            pages that are at the end. If the very last page is allocated, then this method will return zero and
            nothing will change.
            </para>
            <para>
            Upon cancellation via the <paramref name="cancellationToken"/>, this method will
            return the number of pages that were removed before the operation was cancelled.
            Cancellation will <em>not</em> cause data corruption.
            </para>
            <para>
            If <see cref="P:Storage.StreamingPageStorage.IsCapacityFixed"/> is true, then an <see cref="T:System.InvalidOperationException"/> will
            be thrown.
            </para>
            <para>
            If <paramref name="removePageCount"/> is a negative number, then an 
            <see cref="T:System.ArgumentOutOfRangeException"/> will be thrown and the storage will remain
            unchanged. To increase the <see cref="P:Storage.StreamingPageStorage.PageCapacity"/>, use the 
            <see cref="M:Storage.StreamingPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
            method instead.
            </para>
            <para>
            If any <see cref="T:System.Exception"/> is thrown, except the two that were described above, then
            the application is expected to assume that some data has been corrupted.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.StreamingPageStorage.IsCapacityFixed"/>
            is true.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="removePageCount"/>
            is less than zero.</exception>
            <seealso cref="P:Storage.StreamingPageStorage.IsCapacityFixed"/>
            <seealso cref="P:Storage.StreamingPageStorage.PageCapacity"/>
            <seealso cref="M:Storage.StreamingPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Storage.StreamingPageStorage.IsPageAllocated(System.Int64)">
            <summary>
            Checks whether a page is currently allocated.
            </summary>
            <param name="index">The index of the page.</param>
            <returns>True if the page is currently allocated, otherwise false.</returns>
            <remarks>
            If <paramref name="index"/> is out of the range of all pages (allocated and unallocated),
            then false is returned. See <see cref="M:Storage.StreamingPageStorage.IsPageOnStorage(System.Int64)"/>.
            </remarks>
            <seealso cref="M:Storage.StreamingPageStorage.IsPageOnStorage(System.Int64)"/>
            <seealso cref="M:Storage.StreamingPageStorage.TryAllocatePage(System.Int64@)"/>
            <seealso cref="M:Storage.StreamingPageStorage.FreePage(System.Int64)"/>
        </member>
        <member name="M:Storage.StreamingPageStorage.IsPageOnStorage(System.Int64)">
            <summary>
            Checks whether a page exists (regardless of whether or not it is allocated)
            on the storage.
            </summary>
            <param name="index">The index of the page.</param>
            <returns>True if <paramref name="index"/> is greater than or equal to zero and less
            than <see cref="P:Storage.StreamingPageStorage.PageCapacity"/>, otherwise false.</returns>
            <seealso cref="M:Storage.StreamingPageStorage.IsPageAllocated(System.Int64)"/>
            <seealso cref="P:Storage.StreamingPageStorage.PageCapacity"/>
        </member>
        <member name="T:Storage.StreamingPageStorage.InitialPayload">
            <summary>
            -Debug Only- Defines the initial payload for newly allocated pages.
            </summary>
        </member>
        <member name="F:Storage.StreamingPageStorage.InitialPayload.Incremental">
            <summary>
            The initial payload consists of incrementing byte values.
            </summary>
        </member>
        <member name="F:Storage.StreamingPageStorage.InitialPayload.x00">
            <summary>
            The initial payload consists of all zeros.
            </summary>
        </member>
        <member name="F:Storage.StreamingPageStorage.InitialPayload.Unchanged">
            <summary>
            The initial payload is whatever was previously stored.
            </summary>
        </member>
        <member name="P:Storage.StreamingPageStorage.InitialPayloadMode">
            <summary>
            -Debug Only- Defines the initial payload for newly allocated pages.
            </summary>
        </member>
        <member name="M:Storage.StreamingPageStorage.TryAllocatePage(System.Int64@)">
            <summary>
            Attempts to allocate a page.
            </summary>
            <param name="index">Upon success, assigned to the index of the allocated page. Upon
            failure, assigned to -1.</param>
            <returns>True if a page was successfully allocated. False only indicates that there
            is no capacity to allocate a new page.</returns>
            <remarks>
            <para>
            This method will find an unallocated page within the <see cref="P:Storage.StreamingPageStorage.PageCapacity"/>, and
            mark that page as allocated. The application is expected to keep track of the page
            via the assigned <paramref name="index"/>. If there is no unallocated page, then
            false will be returned and nothing will change.
            </para>
            <para>
            Note that this method will never change the <see cref="P:Storage.StreamingPageStorage.PageCapacity"/>. If there are
            no unallocated pages, then the only option to allocate a new page is to call
            <see cref="M:Storage.StreamingPageStorage.TryInflate(System.Int64,System.IProgress{Storage.ProgressReport},System.Threading.CancellationToken)"/>.
            </para>
            <para>
            Also note that the 'initial payload' of a newly allocated page is considered undefined.
            Generally, it will contain a mixture of internal metadata that is used to track unallocated
            pages, and some payload that was stored when the page was previously allocated.
            </para>
            <para>
            If <see cref="P:Storage.StreamingPageStorage.IsReadOnly"/> is true, then an <see cref="T:System.InvalidOperationException"/>
            will be thrown and nothing will change.
            </para>
            <para>
            If any <see cref="T:System.Exception"/> is thrown, except the <see cref="T:System.InvalidOperationException"/>
            described above, then the application is expected to assume that some data has been corrupted.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.StreamingPageStorage.IsReadOnly"/> is true.</exception>
            <exception cref="T:Storage.Data.CorruptDataException">Thrown if any corrupt data is discovered. Note that other
            <see cref="T:System.Exception"/> types may also indicate data corruption.</exception>
            <seealso cref="M:Storage.StreamingPageStorage.FreePage(System.Int64)"/>
            <seealso cref="P:Storage.StreamingPageStorage.IsReadOnly"/>
            <seealso cref="M:Storage.StreamingPageStorage.IsPageAllocated(System.Int64)"/>
            <seealso cref="P:Storage.StreamingPageStorage.AllocatedPageCount"/>
        </member>
        <member name="M:Storage.StreamingPageStorage.FreePage(System.Int64)">
            <summary>
            Deallocates a page.
            </summary>
            <param name="index">The index of the page to deallocate.</param>
            <returns>True if the page was deallocated, false if it was already
            unallocated when this method was called.</returns>
            <remarks>
            <para>
            If the specified page was allocated when this method was called, then 
            it will be marked as deallocated, and the <see cref="P:Storage.StreamingPageStorage.AllocatedPageCount"/>
            will decrease by one, but <see cref="P:Storage.StreamingPageStorage.PageCapacity"/> will remain unchanged.
            If the specified page was not allocated, then false is returned and 
            nothing will change.
            </para>
            <para>
            Note that payload stored in the page will <em>not</em> be erased. If the application has
            written information that it wishes to be erased, it must do so manually before calling this
            method. Otherwise, the payload may continue to exist on the storage, and may even be leaked
            to the application in a future <see cref="M:Storage.StreamingPageStorage.TryAllocatePage(System.Int64@)"/> call, since that
            page may contain the payload that was stored in this to-be-freed page.
            </para>
            <para>
            If <see cref="P:Storage.StreamingPageStorage.IsReadOnly"/> is true, then an <see cref="T:System.InvalidOperationException"/>
            will be thrown and nothing will change.
            </para>
            <para>
            If <paramref name="index"/> is out of the range of valid indices (negative or not less
            than <see cref="P:Storage.StreamingPageStorage.PageCapacity"/>, see <see cref="M:Storage.StreamingPageStorage.IsPageOnStorage(System.Int64)"/>), then an
            <see cref="T:System.ArgumentOutOfRangeException"/> will be thrown and nothing will change.
            </para>
            <para>
            If any <see cref="T:System.Exception"/> is thrown, except the two described above, then the
            application is expected to assume that some data has been corrupted.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:Storage.StreamingPageStorage.IsReadOnly"/> is true.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="index"/> is negative or
            greater than or equal to <see cref="P:Storage.StreamingPageStorage.PageCapacity"/>. See <see cref="M:Storage.StreamingPageStorage.IsPageOnStorage(System.Int64)"/>.</exception>
            <seealso cref="M:Storage.StreamingPageStorage.TryAllocatePage(System.Int64@)"/>
            <seealso cref="P:Storage.StreamingPageStorage.IsReadOnly"/>
            <seealso cref="M:Storage.StreamingPageStorage.IsPageAllocated(System.Int64)"/>
            <seealso cref="P:Storage.StreamingPageStorage.AllocatedPageCount"/>
        </member>
        <member name="M:Storage.StreamingPageStorage.ReadFrom(System.Int64,System.Int64,System.Byte[],System.Int64,System.Int64)">
            <summary>
            Reads payload from an allocated page.
            </summary>
            <param name="pageIndex">The index of the allocated page.</param>
            <param name="srcOffset">The source offset within the page's payload, measured in bytes.</param>
            <param name="buffer">The destination buffer.</param>
            <param name="dstOffset">The destination offset within the destination <paramref name="buffer"/>,
            measured in bytes.</param>
            <param name="length">The number of bytes to read.</param>
            <remarks>
            <para>
            If <paramref name="pageIndex"/> refers to an unallocated page, then an
            <see cref="T:System.InvalidOperationException"/> will be thrown.
            </para>
            <para>
            If any of the payload position/length arguments are out of their valid range, an
            <see cref="T:System.ArgumentOutOfRangeException"/> will be thrown.
            </para>
            <para>
            If <paramref name="buffer"/> is null, then an <see cref="T:System.ArgumentNullException"/> will
            be thrown.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <paramref name="pageIndex"/> does not refer to
            an allocated page.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="srcOffset"/>,
            <paramref name="dstOffset"/>, or <paramref name="length"/> is negative; or if the sum of
            <paramref name="srcOffset"/> and <paramref name="length"/> is greater than <see cref="P:Storage.StreamingPageStorage.PageSize"/>;
            or if the sum of <paramref name="dstOffset"/> and <paramref name="length"/> is greater than
            the <paramref name="buffer"/> size; or if <paramref name="dstOffset"/> or <paramref name="length"/>
            is greater than <see cref="F:System.Int32.MaxValue"/> (since the <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/>
            method does not accept long arguments).
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <seealso cref="M:Storage.StreamingPageStorage.WriteTo(System.Int64,System.Int64,System.Byte[],System.Int64,System.Int64)"/>
            <seealso cref="M:Storage.StreamingPageStorage.IsPageAllocated(System.Int64)"/>
        </member>
        <member name="M:Storage.StreamingPageStorage.WriteTo(System.Int64,System.Int64,System.Byte[],System.Int64,System.Int64)">
            <summary>
            Writes payload to an allocated page.
            </summary>
            <param name="pageIndex">The index of the allocated page.</param>
            <param name="dstOffset">The destination offset within the page's payload, measured in 
            bytes.</param>
            <param name="buffer">The source buffer.</param>
            <param name="srcOffset">The source offset within the source <paramref name="buffer"/>,
            measured in bytes.</param>
            <param name="length">The number of bytes to write.</param>
            <remarks>
            <para>
            If <paramref name="pageIndex"/> refers to an unallocated page, or if <see cref="P:Storage.StreamingPageStorage.IsReadOnly"/>
            is true, then an <see cref="T:System.InvalidOperationException"/> will be thrown and nothing
            will change.
            </para>
            <para>
            If any of the payload position/length arguments are out of their valid range, an
            <see cref="T:System.ArgumentOutOfRangeException"/> will be thrown and nothing will change.
            </para>
            <para>
            If <paramref name="buffer"/> is null, then an <see cref="T:System.ArgumentNullException"/>
            will be thrown.
            </para>
            <para>
            If any <see cref="T:System.Exception"/> is thrown, except those described above, then the
            application is expected to assume that some data may have been corrupted.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if <paramref name="pageIndex"/> refers
            to an unallocated page, or if <see cref="P:Storage.StreamingPageStorage.IsReadOnly"/> is true.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="srcOffset"/>,
            <paramref name="dstOffset"/>, or <paramref name="length"/> is negative; or if
            the sum of <paramref name="dstOffset"/> and <paramref name="length"/> is greater
            than <see cref="P:Storage.StreamingPageStorage.PageSize"/>; or if the sum of <paramref name="srcOffset"/> and
            <paramref name="length"/> is greater than the <paramref name="buffer"/> size; or
            if <paramref name="srcOffset"/> or <paramref name="length"/> is greater than
            <see cref="F:System.Int32.MaxValue"/> (since the <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)"/>
            method does not accept long arguments).
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="buffer"/> is null.</exception>
            <seealso cref="M:Storage.StreamingPageStorage.ReadFrom(System.Int64,System.Int64,System.Byte[],System.Int64,System.Int64)"/>
            <seealso cref="P:Storage.StreamingPageStorage.IsReadOnly"/>
            <seealso cref="M:Storage.StreamingPageStorage.IsPageAllocated(System.Int64)"/>
        </member>
        <member name="P:Storage.StreamingPageStorage.IsDisposed">
            <summary>
            Has the <see cref="M:Storage.StreamingPageStorage.Dispose"/> method been called?
            </summary>
        </member>
        <member name="M:Storage.StreamingPageStorage.Dispose">
            <summary>
            Disposes this <see cref="T:Storage.StreamingPageStorage"/>.
            </summary>
            <remarks>
            <para>
            The base <see cref="T:System.IO.Stream"/> will be flushed via <see cref="M:System.IO.Stream.Flush"/>,
            though this should be redundant since the <see cref="M:Storage.StreamingPageStorage.WriteTo(System.Int64,System.Int64,System.Byte[],System.Int64,System.Int64)"/>
            method automatically flushes it.
            </para>
            <para>
            If the constructor specified that the base <see cref="T:System.IO.Stream"/> should <em>not</em>
            remain open (un-disposed), then the <see cref="M:System.IO.Stream.Dispose"/> method will be
            called.
            </para>
            </remarks>
            <seealso cref="P:Storage.StreamingPageStorage.IsDisposed"/>
        </member>
    </members>
</doc>
